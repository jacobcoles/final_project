{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _slicedToArray = require(\"/Users/jacobcoles/Desktop/LT2216/final_project/final_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/jacobcoles/Desktop/LT2216/final_project/final_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transcode = exports.requestChangeCase = exports.flattenObject = exports.match = exports.applyPattern = exports.encodeWithoutSlashes = exports.encodeWithSlashes = exports.buildQueryStringComponents = exports.deleteField = exports.deepCopy = exports.getField = void 0;\n\nconst util_1 = require(\"./util\");\n\nconst httpOptionName = '(google.api.http)'; // List of methods as defined in google/api/http.proto (see HttpRule)\n\nconst supportedHttpMethods = ['get', 'post', 'put', 'patch', 'delete'];\n\nfunction getField(request, field) {\n  const parts = field.split('.');\n  let value = request;\n\n  var _iterator = _createForOfIteratorHelper(parts),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      const part = _step.value;\n\n      if (typeof value !== 'object') {\n        return undefined;\n      }\n\n      value = value[part];\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (typeof value === 'object' && !Array.isArray(value) && value !== null) {\n    return undefined;\n  }\n\n  return value;\n}\n\nexports.getField = getField;\n\nfunction deepCopy(request) {\n  if (typeof request !== 'object' || request === null) {\n    return request;\n  }\n\n  const copy = Object.assign({}, request);\n\n  for (const key in copy) {\n    if (Array.isArray(copy[key])) {\n      copy[key] = copy[key].map(deepCopy);\n    } else if (typeof copy[key] === 'object' && copy[key] !== null) {\n      copy[key] = deepCopy(copy[key]);\n    }\n  }\n\n  return copy;\n}\n\nexports.deepCopy = deepCopy;\n\nfunction deleteField(request, field) {\n  const parts = field.split('.');\n\n  while (parts.length > 1) {\n    if (typeof request !== 'object') {\n      return;\n    }\n\n    const part = parts.shift();\n    request = request[part];\n  }\n\n  const part = parts.shift();\n\n  if (typeof request !== 'object') {\n    return;\n  }\n\n  delete request[part];\n}\n\nexports.deleteField = deleteField;\n\nfunction buildQueryStringComponents(request, prefix = '') {\n  const resultList = [];\n\n  for (const key in request) {\n    if (Array.isArray(request[key])) {\n      var _iterator2 = _createForOfIteratorHelper(request[key]),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          const value = _step2.value;\n          resultList.push(\"\".concat(prefix).concat(encodeWithoutSlashes(key), \"=\").concat(encodeWithoutSlashes(value.toString())));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } else if (typeof request[key] === 'object' && request[key] !== null) {\n      resultList.push(...buildQueryStringComponents(request[key], \"\".concat(key, \".\")));\n    } else {\n      resultList.push(\"\".concat(prefix).concat(encodeWithoutSlashes(key), \"=\").concat(encodeWithoutSlashes(request[key].toString())));\n    }\n  }\n\n  return resultList;\n}\n\nexports.buildQueryStringComponents = buildQueryStringComponents;\n\nfunction encodeWithSlashes(str) {\n  return str.split('').map(c => c.match(/[-_.~0-9a-zA-Z]/) ? c : encodeURIComponent(c)).join('');\n}\n\nexports.encodeWithSlashes = encodeWithSlashes;\n\nfunction encodeWithoutSlashes(str) {\n  return str.split('').map(c => c.match(/[-_.~0-9a-zA-Z/]/) ? c : encodeURIComponent(c)).join('');\n}\n\nexports.encodeWithoutSlashes = encodeWithoutSlashes;\n\nfunction escapeRegExp(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction applyPattern(pattern, fieldValue) {\n  if (!pattern || pattern === '*') {\n    return encodeWithSlashes(fieldValue);\n  }\n\n  if (!pattern.includes('*') && pattern !== fieldValue) {\n    return undefined;\n  } // since we're converting the pattern to a regex, make necessary precautions:\n\n\n  const regex = new RegExp('^' + escapeRegExp(pattern).replace(/\\\\\\*\\\\\\*/g, '(.+)').replace(/\\\\\\*/g, '([^/]+)') + '$');\n\n  if (!fieldValue.match(regex)) {\n    return undefined;\n  }\n\n  return encodeWithoutSlashes(fieldValue);\n}\n\nexports.applyPattern = applyPattern;\n\nfunction match(request, pattern) {\n  let url = pattern;\n  const matchedFields = [];\n\n  for (;;) {\n    const match = url.match(/^(.*)\\{([^}=]+)(?:=([^}]*))?\\}(.*)/);\n\n    if (!match) {\n      break;\n    }\n\n    const _match = _slicedToArray(match, 5),\n          before = _match[1],\n          field = _match[2],\n          pattern = _match[3],\n          after = _match[4];\n\n    matchedFields.push(field);\n    const fieldValue = getField(request, field);\n\n    if (typeof fieldValue === 'undefined') {\n      return undefined;\n    }\n\n    const appliedPattern = applyPattern(pattern, fieldValue.toString());\n\n    if (typeof appliedPattern === 'undefined') {\n      return undefined;\n    }\n\n    url = before + appliedPattern + after;\n  }\n\n  return {\n    matchedFields,\n    url\n  };\n}\n\nexports.match = match;\n\nfunction flattenObject(request) {\n  const result = {};\n\n  for (const key in request) {\n    if (typeof request[key] === 'undefined') {\n      continue;\n    }\n\n    if (Array.isArray(request[key])) {\n      // According to the http.proto comments, a repeated field may only\n      // contain primitive types, so no extra recursion here.\n      result[key] = request[key];\n      continue;\n    }\n\n    if (typeof request[key] === 'object' && request[key] !== null) {\n      const nested = flattenObject(request[key]);\n\n      for (const nestedKey in nested) {\n        result[\"\".concat(key, \".\").concat(nestedKey)] = nested[nestedKey];\n      }\n\n      continue;\n    }\n\n    result[key] = request[key];\n  }\n\n  return result;\n}\n\nexports.flattenObject = flattenObject;\n\nfunction requestChangeCase(request, caseChangeFunc) {\n  if (!request || typeof request !== 'object') {\n    return request;\n  }\n\n  const convertedRequest = {};\n\n  for (const field in request) {\n    const convertedField = caseChangeFunc(field);\n    const value = request[field];\n\n    if (Array.isArray(value)) {\n      convertedRequest[convertedField] = value.map(v => requestChangeCase(v, caseChangeFunc));\n    } else {\n      convertedRequest[convertedField] = requestChangeCase(value, caseChangeFunc);\n    }\n  }\n\n  return convertedRequest;\n}\n\nexports.requestChangeCase = requestChangeCase;\n\nfunction transcode(request, parsedOptions) {\n  // request is supposed to have keys in camelCase.\n  const snakeRequest = requestChangeCase(request, util_1.camelToSnakeCase);\n  const httpRules = [];\n\n  var _iterator3 = _createForOfIteratorHelper(parsedOptions),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      const option = _step3.value;\n\n      if (!(httpOptionName in option)) {\n        continue;\n      }\n\n      const httpRule = option[httpOptionName];\n      httpRules.push(httpRule);\n\n      if (httpRule === null || httpRule === void 0 ? void 0 : httpRule.additional_bindings) {\n        const additionalBindings = Array.isArray(httpRule.additional_bindings) ? httpRule.additional_bindings : [httpRule.additional_bindings];\n        httpRules.push(...additionalBindings);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  for (var _i = 0, _httpRules = httpRules; _i < _httpRules.length; _i++) {\n    const httpRule = _httpRules[_i];\n\n    var _iterator4 = _createForOfIteratorHelper(supportedHttpMethods),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        const httpMethod = _step4.value;\n\n        if (!(httpMethod in httpRule)) {\n          continue;\n        }\n\n        const pathTemplate = httpRule[httpMethod];\n        const matchResult = match(snakeRequest, pathTemplate);\n\n        if (typeof matchResult === 'undefined') {\n          continue;\n        }\n\n        const url = matchResult.url,\n              matchedFields = matchResult.matchedFields;\n\n        if (httpRule.body === '*') {\n          // all fields except the matched fields go to request data\n          const data = deepCopy(snakeRequest);\n\n          var _iterator5 = _createForOfIteratorHelper(matchedFields),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              const field = _step5.value;\n              deleteField(data, field);\n            } // HTTP endpoint expects camelCase but we have snake_case at this point\n\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          const camelCaseData = requestChangeCase(data, util_1.snakeToCamelCase);\n          return {\n            httpMethod,\n            url,\n            queryString: '',\n            data: camelCaseData\n          };\n        } // one field possibly goes to request data, others go to query string\n\n\n        const body = httpRule.body;\n        let data = '';\n        const queryStringObject = deepCopy(request); // use camel case for query string\n\n        if (body) {\n          deleteField(queryStringObject, util_1.snakeToCamelCase(body));\n          data = snakeRequest[body];\n        }\n\n        var _iterator6 = _createForOfIteratorHelper(matchedFields),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            const field = _step6.value;\n            deleteField(queryStringObject, util_1.snakeToCamelCase(field));\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        const queryStringComponents = buildQueryStringComponents(queryStringObject);\n        const queryString = queryStringComponents.join('&');\n        let camelCaseData;\n\n        if (typeof data === 'string') {\n          camelCaseData = data;\n        } else {\n          camelCaseData = requestChangeCase(data, util_1.snakeToCamelCase);\n        }\n\n        return {\n          httpMethod,\n          url,\n          queryString,\n          data: camelCaseData\n        };\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n\n  return undefined;\n}\n\nexports.transcode = transcode;","map":{"version":3,"sources":["../../src/transcoding.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.transcode = exports.requestChangeCase = exports.flattenObject = exports.match = exports.applyPattern = exports.encodeWithoutSlashes = exports.encodeWithSlashes = exports.buildQueryStringComponents = exports.deleteField = exports.deepCopy = exports.getField = void 0;\nconst util_1 = require(\"./util\");\nconst httpOptionName = '(google.api.http)';\n// List of methods as defined in google/api/http.proto (see HttpRule)\nconst supportedHttpMethods = ['get', 'post', 'put', 'patch', 'delete'];\nfunction getField(request, field) {\n    const parts = field.split('.');\n    let value = request;\n    for (const part of parts) {\n        if (typeof value !== 'object') {\n            return undefined;\n        }\n        value = value[part];\n    }\n    if (typeof value === 'object' && !Array.isArray(value) && value !== null) {\n        return undefined;\n    }\n    return value;\n}\nexports.getField = getField;\nfunction deepCopy(request) {\n    if (typeof request !== 'object' || request === null) {\n        return request;\n    }\n    const copy = Object.assign({}, request);\n    for (const key in copy) {\n        if (Array.isArray(copy[key])) {\n            copy[key] = copy[key].map(deepCopy);\n        }\n        else if (typeof copy[key] === 'object' && copy[key] !== null) {\n            copy[key] = deepCopy(copy[key]);\n        }\n    }\n    return copy;\n}\nexports.deepCopy = deepCopy;\nfunction deleteField(request, field) {\n    const parts = field.split('.');\n    while (parts.length > 1) {\n        if (typeof request !== 'object') {\n            return;\n        }\n        const part = parts.shift();\n        request = request[part];\n    }\n    const part = parts.shift();\n    if (typeof request !== 'object') {\n        return;\n    }\n    delete request[part];\n}\nexports.deleteField = deleteField;\nfunction buildQueryStringComponents(request, prefix = '') {\n    const resultList = [];\n    for (const key in request) {\n        if (Array.isArray(request[key])) {\n            for (const value of request[key]) {\n                resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(value.toString())}`);\n            }\n        }\n        else if (typeof request[key] === 'object' && request[key] !== null) {\n            resultList.push(...buildQueryStringComponents(request[key], `${key}.`));\n        }\n        else {\n            resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(request[key].toString())}`);\n        }\n    }\n    return resultList;\n}\nexports.buildQueryStringComponents = buildQueryStringComponents;\nfunction encodeWithSlashes(str) {\n    return str\n        .split('')\n        .map(c => (c.match(/[-_.~0-9a-zA-Z]/) ? c : encodeURIComponent(c)))\n        .join('');\n}\nexports.encodeWithSlashes = encodeWithSlashes;\nfunction encodeWithoutSlashes(str) {\n    return str\n        .split('')\n        .map(c => (c.match(/[-_.~0-9a-zA-Z/]/) ? c : encodeURIComponent(c)))\n        .join('');\n}\nexports.encodeWithoutSlashes = encodeWithoutSlashes;\nfunction escapeRegExp(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction applyPattern(pattern, fieldValue) {\n    if (!pattern || pattern === '*') {\n        return encodeWithSlashes(fieldValue);\n    }\n    if (!pattern.includes('*') && pattern !== fieldValue) {\n        return undefined;\n    }\n    // since we're converting the pattern to a regex, make necessary precautions:\n    const regex = new RegExp('^' +\n        escapeRegExp(pattern)\n            .replace(/\\\\\\*\\\\\\*/g, '(.+)')\n            .replace(/\\\\\\*/g, '([^/]+)') +\n        '$');\n    if (!fieldValue.match(regex)) {\n        return undefined;\n    }\n    return encodeWithoutSlashes(fieldValue);\n}\nexports.applyPattern = applyPattern;\nfunction match(request, pattern) {\n    let url = pattern;\n    const matchedFields = [];\n    for (;;) {\n        const match = url.match(/^(.*)\\{([^}=]+)(?:=([^}]*))?\\}(.*)/);\n        if (!match) {\n            break;\n        }\n        const [, before, field, pattern, after] = match;\n        matchedFields.push(field);\n        const fieldValue = getField(request, field);\n        if (typeof fieldValue === 'undefined') {\n            return undefined;\n        }\n        const appliedPattern = applyPattern(pattern, fieldValue.toString());\n        if (typeof appliedPattern === 'undefined') {\n            return undefined;\n        }\n        url = before + appliedPattern + after;\n    }\n    return { matchedFields, url };\n}\nexports.match = match;\nfunction flattenObject(request) {\n    const result = {};\n    for (const key in request) {\n        if (typeof request[key] === 'undefined') {\n            continue;\n        }\n        if (Array.isArray(request[key])) {\n            // According to the http.proto comments, a repeated field may only\n            // contain primitive types, so no extra recursion here.\n            result[key] = request[key];\n            continue;\n        }\n        if (typeof request[key] === 'object' && request[key] !== null) {\n            const nested = flattenObject(request[key]);\n            for (const nestedKey in nested) {\n                result[`${key}.${nestedKey}`] = nested[nestedKey];\n            }\n            continue;\n        }\n        result[key] = request[key];\n    }\n    return result;\n}\nexports.flattenObject = flattenObject;\nfunction requestChangeCase(request, caseChangeFunc) {\n    if (!request || typeof request !== 'object') {\n        return request;\n    }\n    const convertedRequest = {};\n    for (const field in request) {\n        const convertedField = caseChangeFunc(field);\n        const value = request[field];\n        if (Array.isArray(value)) {\n            convertedRequest[convertedField] = value.map(v => requestChangeCase(v, caseChangeFunc));\n        }\n        else {\n            convertedRequest[convertedField] = requestChangeCase(value, caseChangeFunc);\n        }\n    }\n    return convertedRequest;\n}\nexports.requestChangeCase = requestChangeCase;\nfunction transcode(request, parsedOptions) {\n    // request is supposed to have keys in camelCase.\n    const snakeRequest = requestChangeCase(request, util_1.camelToSnakeCase);\n    const httpRules = [];\n    for (const option of parsedOptions) {\n        if (!(httpOptionName in option)) {\n            continue;\n        }\n        const httpRule = option[httpOptionName];\n        httpRules.push(httpRule);\n        if (httpRule === null || httpRule === void 0 ? void 0 : httpRule.additional_bindings) {\n            const additionalBindings = Array.isArray(httpRule.additional_bindings)\n                ? httpRule.additional_bindings\n                : [httpRule.additional_bindings];\n            httpRules.push(...additionalBindings);\n        }\n    }\n    for (const httpRule of httpRules) {\n        for (const httpMethod of supportedHttpMethods) {\n            if (!(httpMethod in httpRule)) {\n                continue;\n            }\n            const pathTemplate = httpRule[httpMethod];\n            const matchResult = match(snakeRequest, pathTemplate);\n            if (typeof matchResult === 'undefined') {\n                continue;\n            }\n            const { url, matchedFields } = matchResult;\n            if (httpRule.body === '*') {\n                // all fields except the matched fields go to request data\n                const data = deepCopy(snakeRequest);\n                for (const field of matchedFields) {\n                    deleteField(data, field);\n                }\n                // HTTP endpoint expects camelCase but we have snake_case at this point\n                const camelCaseData = requestChangeCase(data, util_1.snakeToCamelCase);\n                return { httpMethod, url, queryString: '', data: camelCaseData };\n            }\n            // one field possibly goes to request data, others go to query string\n            const body = httpRule.body;\n            let data = '';\n            const queryStringObject = deepCopy(request); // use camel case for query string\n            if (body) {\n                deleteField(queryStringObject, util_1.snakeToCamelCase(body));\n                data = snakeRequest[body];\n            }\n            for (const field of matchedFields) {\n                deleteField(queryStringObject, util_1.snakeToCamelCase(field));\n            }\n            const queryStringComponents = buildQueryStringComponents(queryStringObject);\n            const queryString = queryStringComponents.join('&');\n            let camelCaseData;\n            if (typeof data === 'string') {\n                camelCaseData = data;\n            }\n            else {\n                camelCaseData = requestChangeCase(data, util_1.snakeToCamelCase);\n            }\n            return { httpMethod, url, queryString, data: camelCaseData };\n        }\n    }\n    return undefined;\n}\nexports.transcode = transcode;\n//# sourceMappingURL=transcoding.js.map"]},"metadata":{},"sourceType":"script"}