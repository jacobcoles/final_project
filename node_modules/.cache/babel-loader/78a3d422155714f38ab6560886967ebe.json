{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/jacobcoles/Desktop/LT2216/final_project/final_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst net_1 = __importDefault(require(\"net\"));\n\nconst tls_1 = __importDefault(require(\"tls\"));\n\nconst url_1 = __importDefault(require(\"url\"));\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst agent_base_1 = require(\"agent-base\");\n\nconst parse_proxy_response_1 = __importDefault(require(\"./parse-proxy-response\"));\n\nconst debug = debug_1.default('https-proxy-agent:agent');\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n *\n * @api public\n */\n\nclass HttpsProxyAgent extends agent_base_1.Agent {\n  constructor(_opts) {\n    let opts;\n\n    if (typeof _opts === 'string') {\n      opts = url_1.default.parse(_opts);\n    } else {\n      opts = _opts;\n    }\n\n    if (!opts) {\n      throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n    }\n\n    debug('creating new HttpsProxyAgent instance: %o', opts);\n    super(opts);\n    const proxy = Object.assign({}, opts); // If `true`, then connect to the proxy server over TLS.\n    // Defaults to `false`.\n\n    this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol); // Prefer `hostname` over `host`, and set the `port` if needed.\n\n    proxy.host = proxy.hostname || proxy.host;\n\n    if (typeof proxy.port === 'string') {\n      proxy.port = parseInt(proxy.port, 10);\n    }\n\n    if (!proxy.port && proxy.host) {\n      proxy.port = this.secureProxy ? 443 : 80;\n    } // ALPN is supported by Node.js >= v5.\n    // attempt to negotiate http/1.1 for proxy servers that support http/2\n\n\n    if (this.secureProxy && !('ALPNProtocols' in proxy)) {\n      proxy.ALPNProtocols = ['http 1.1'];\n    }\n\n    if (proxy.host && proxy.path) {\n      // If both a `host` and `path` are specified then it's most likely\n      // the result of a `url.parse()` call... we need to remove the\n      // `path` portion so that `net.connect()` doesn't attempt to open\n      // that as a Unix socket file.\n      delete proxy.path;\n      delete proxy.pathname;\n    }\n\n    this.proxy = proxy;\n  }\n  /**\n   * Called when the node-core HTTP client library is creating a\n   * new HTTP request.\n   *\n   * @api protected\n   */\n\n\n  callback(req, opts) {\n    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var proxy, secureProxy, socket, headers, hostname, payload, host, port, secureEndpoint, _i, _Object$keys, name, proxyResponsePromise, _yield$proxyResponseP, statusCode, buffered, servername, fakeSocket;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            proxy = this.proxy, secureProxy = this.secureProxy; // Create a socket connection to the proxy server.\n\n            if (secureProxy) {\n              debug('Creating `tls.Socket`: %o', proxy);\n              socket = tls_1.default.connect(proxy);\n            } else {\n              debug('Creating `net.Socket`: %o', proxy);\n              socket = net_1.default.connect(proxy);\n            }\n\n            headers = Object.assign({}, proxy.headers);\n            hostname = \"\".concat(opts.host, \":\").concat(opts.port);\n            payload = \"CONNECT \".concat(hostname, \" HTTP/1.1\\r\\n\"); // Inject the `Proxy-Authorization` header if necessary.\n\n            if (proxy.auth) {\n              headers['Proxy-Authorization'] = \"Basic \".concat(Buffer.from(proxy.auth).toString('base64'));\n            } // The `Host` header should only include the port\n            // number when it is not the default port.\n\n\n            host = opts.host, port = opts.port, secureEndpoint = opts.secureEndpoint;\n\n            if (!isDefaultPort(port, secureEndpoint)) {\n              host += \":\".concat(port);\n            }\n\n            headers.Host = host;\n            headers.Connection = 'close';\n\n            for (_i = 0, _Object$keys = Object.keys(headers); _i < _Object$keys.length; _i++) {\n              name = _Object$keys[_i];\n              payload += \"\".concat(name, \": \").concat(headers[name], \"\\r\\n\");\n            }\n\n            proxyResponsePromise = parse_proxy_response_1.default(socket);\n            socket.write(\"\".concat(payload, \"\\r\\n\"));\n            _context.next = 15;\n            return proxyResponsePromise;\n\n          case 15:\n            _yield$proxyResponseP = _context.sent;\n            statusCode = _yield$proxyResponseP.statusCode;\n            buffered = _yield$proxyResponseP.buffered;\n\n            if (!(statusCode === 200)) {\n              _context.next = 27;\n              break;\n            }\n\n            req.once('socket', resume);\n\n            if (!opts.secureEndpoint) {\n              _context.next = 26;\n              break;\n            }\n\n            servername = opts.servername || opts.host;\n\n            if (servername) {\n              _context.next = 24;\n              break;\n            }\n\n            throw new Error('Could not determine \"servername\"');\n\n          case 24:\n            // The proxy is connecting to a TLS server, so upgrade\n            // this socket connection to a TLS connection.\n            debug('Upgrading socket connection to TLS');\n            return _context.abrupt(\"return\", tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), {\n              socket,\n              servername\n            })));\n\n          case 26:\n            return _context.abrupt(\"return\", socket);\n\n          case 27:\n            // Some other status code that's not 200... need to re-play the HTTP\n            // header \"data\" events onto the socket once the HTTP machinery is\n            // attached so that the node core `http` can parse and handle the\n            // error status code.\n            // Close the original socket, and a new \"fake\" socket is returned\n            // instead, so that the proxy doesn't get the HTTP request\n            // written to it (which may contain `Authorization` headers or other\n            // sensitive data).\n            //\n            // See: https://hackerone.com/reports/541502\n            socket.destroy();\n            fakeSocket = new net_1.default.Socket();\n            fakeSocket.readable = true; // Need to wait for the \"socket\" event to re-play the \"data\" events.\n\n            req.once('socket', s => {\n              debug('replaying proxy buffer for failed request');\n              assert_1.default(s.listenerCount('data') > 0); // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n              // this point the HTTP module machinery has been hooked up for\n              // the user.\n\n              s.push(buffered);\n              s.push(null);\n            });\n            return _context.abrupt(\"return\", fakeSocket);\n\n          case 32:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, this);\n    }));\n  }\n\n}\n\nexports.default = HttpsProxyAgent;\n\nfunction resume(socket) {\n  socket.resume();\n}\n\nfunction isDefaultPort(port, secure) {\n  return Boolean(!secure && port === 80 || secure && port === 443);\n}\n\nfunction isHTTPS(protocol) {\n  return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\n\nfunction omit(obj, ...keys) {\n  const ret = {};\n  let key;\n\n  for (key in obj) {\n    if (!keys.includes(key)) {\n      ret[key] = obj[key];\n    }\n  }\n\n  return ret;\n}","map":{"version":3,"sources":["../src/agent.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,KAAA,GAAA,eAAA,CAAA,OAAA,CAAA,KAAA,CAAA,CAAA;;AACA,MAAA,KAAA,GAAA,eAAA,CAAA,OAAA,CAAA,KAAA,CAAA,CAAA;;AACA,MAAA,KAAA,GAAA,eAAA,CAAA,OAAA,CAAA,KAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;;AACA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AAEA,MAAA,YAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAA,sBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,wBAAA,CAAA,CAAA;;AAEA,MAAM,KAAK,GAAG,OAAA,CAAA,OAAA,CAAY,yBAAZ,CAAd;AAEA;;;;;;;;;;;;;AAaG;;AACH,MAAqB,eAArB,SAA6C,YAAA,CAAA,KAA7C,CAAkD;AAIjD,EAAA,WAAA,CAAY,KAAZ,EAAkD;AACjD,QAAI,IAAJ;;AACA,QAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC9B,MAAA,IAAI,GAAG,KAAA,CAAA,OAAA,CAAI,KAAJ,CAAU,KAAV,CAAP;AACA,KAFD,MAEO;AACN,MAAA,IAAI,GAAG,KAAP;AACA;;AACD,QAAI,CAAC,IAAL,EAAW;AACV,YAAM,IAAI,KAAJ,CACL,8DADK,CAAN;AAGA;;AACD,IAAA,KAAK,CAAC,2CAAD,EAA8C,IAA9C,CAAL;AACA,UAAM,IAAN;AAEA,UAAM,KAAK,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAgC,IAAhC,CAAX,CAfiD,CAiBjD;AACA;;AACA,SAAK,WAAL,GAAmB,IAAI,CAAC,WAAL,IAAoB,OAAO,CAAC,KAAK,CAAC,QAAP,CAA9C,CAnBiD,CAqBjD;;AACA,IAAA,KAAK,CAAC,IAAN,GAAa,KAAK,CAAC,QAAN,IAAkB,KAAK,CAAC,IAArC;;AACA,QAAI,OAAO,KAAK,CAAC,IAAb,KAAsB,QAA1B,EAAoC;AACnC,MAAA,KAAK,CAAC,IAAN,GAAa,QAAQ,CAAC,KAAK,CAAC,IAAP,EAAa,EAAb,CAArB;AACA;;AACD,QAAI,CAAC,KAAK,CAAC,IAAP,IAAe,KAAK,CAAC,IAAzB,EAA+B;AAC9B,MAAA,KAAK,CAAC,IAAN,GAAa,KAAK,WAAL,GAAmB,GAAnB,GAAyB,EAAtC;AACA,KA5BgD,CA8BjD;AACA;;;AACA,QAAI,KAAK,WAAL,IAAoB,EAAE,mBAAmB,KAArB,CAAxB,EAAqD;AACpD,MAAA,KAAK,CAAC,aAAN,GAAsB,CAAC,UAAD,CAAtB;AACA;;AAED,QAAI,KAAK,CAAC,IAAN,IAAc,KAAK,CAAC,IAAxB,EAA8B;AAC7B;AACA;AACA;AACA;AACA,aAAO,KAAK,CAAC,IAAb;AACA,aAAO,KAAK,CAAC,QAAb;AACA;;AAED,SAAK,KAAL,GAAa,KAAb;AACA;AAED;;;;;AAKG;;;AACG,EAAA,QAAQ,CACb,GADa,EAEb,IAFa,EAEO;;;;;;;AAEZ,YAAA,K,GAAuB,I,CAAvB,K,EAAO,W,GAAgB,I,CAAhB,W,EAEf;;AAEA,gBAAI,WAAJ,EAAiB;AAChB,cAAA,KAAK,CAAC,2BAAD,EAA8B,KAA9B,CAAL;AACA,cAAA,MAAM,GAAG,KAAA,CAAA,OAAA,CAAI,OAAJ,CAAY,KAAZ,CAAT;AACA,aAHD,MAGO;AACN,cAAA,KAAK,CAAC,2BAAD,EAA8B,KAA9B,CAAL;AACA,cAAA,MAAM,GAAG,KAAA,CAAA,OAAA,CAAI,OAAJ,CAAY,KAAZ,CAAT;AACA;;AAEK,YAAA,O,GAAO,MAAA,CAAA,MAAA,CAAA,EAAA,EAA6B,KAAK,CAAC,OAAnC,C;AACP,YAAA,Q,aAAc,IAAI,CAAC,I,cAAQ,IAAI,CAAC,I;AAClC,YAAA,O,qBAAqB,Q,oBAEzB;;AACA,gBAAI,KAAK,CAAC,IAAV,EAAgB;AACf,cAAA,OAAO,CAAC,qBAAD,CAAP,mBAA0C,MAAM,CAAC,IAAP,CACzC,KAAK,CAAC,IADmC,EAExC,QAFwC,CAE/B,QAF+B,CAA1C;AAGA,a,CAED;AACA;;;AACM,YAAA,I,GAA+B,I,CAA/B,I,EAAM,I,GAAyB,I,CAAzB,I,EAAM,c,GAAmB,I,CAAnB,c;;AAClB,gBAAI,CAAC,aAAa,CAAC,IAAD,EAAO,cAAP,CAAlB,EAA0C;AACzC,cAAA,IAAI,eAAQ,IAAR,CAAJ;AACA;;AACD,YAAA,OAAO,CAAC,IAAR,GAAe,IAAf;AAEA,YAAA,OAAO,CAAC,UAAR,GAAqB,OAArB;;AACA,wCAAmB,MAAM,CAAC,IAAP,CAAY,OAAZ,CAAnB,kCAAyC;AAA9B,cAAA,IAA8B;AACxC,cAAA,OAAO,cAAO,IAAP,eAAgB,OAAO,CAAC,IAAD,CAAvB,SAAP;AACA;;AAEK,YAAA,oB,GAAuB,sBAAA,CAAA,OAAA,CAAmB,MAAnB,C;AAE7B,YAAA,MAAM,CAAC,KAAP,WAAgB,OAAhB;;AAKI,mBAAM,oBAAN;;;;AAFH,YAAA,U,yBAAA,U;AACA,YAAA,Q,yBAAA,Q;;kBAGG,UAAU,KAAK,G;;;;;AAClB,YAAA,GAAG,CAAC,IAAJ,CAAS,QAAT,EAAmB,MAAnB;;iBAEI,IAAI,CAAC,c;;;;;AACF,YAAA,U,GAAa,IAAI,CAAC,UAAL,IAAmB,IAAI,CAAC,I;;gBACtC,U;;;;;kBACE,IAAI,KAAJ,CAAU,kCAAV,C;;;AAEP;AACA;AACA,YAAA,KAAK,CAAC,oCAAD,CAAL;6CACO,KAAA,CAAA,OAAA,CAAI,OAAJ,CAAW,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACd,IAAI,CAAC,IAAD,EAAO,MAAP,EAAe,UAAf,EAA2B,MAA3B,EAAmC,MAAnC,CADU,CAAA,EACgC;AACjD,cAAA,MADiD;AAEjD,cAAA;AAFiD,aADhC,CAAX,C;;;6CAOD,M;;;AAGR;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAA,MAAM,CAAC,OAAP;AAEM,YAAA,U,GAAa,IAAI,KAAA,CAAA,OAAA,CAAI,MAAR,E;AACnB,YAAA,UAAU,CAAC,QAAX,GAAsB,IAAtB,C,CAEA;;AACA,YAAA,GAAG,CAAC,IAAJ,CAAS,QAAT,EAAoB,CAAD,IAAkB;AACpC,cAAA,KAAK,CAAC,2CAAD,CAAL;AACA,cAAA,QAAA,CAAA,OAAA,CAAO,CAAC,CAAC,aAAF,CAAgB,MAAhB,IAA0B,CAAjC,EAFoC,CAIpC;AACA;AACA;;AACA,cAAA,CAAC,CAAC,IAAF,CAAO,QAAP;AACA,cAAA,CAAC,CAAC,IAAF,CAAO,IAAP;AACA,aATD;6CAWO,U;;;;;;;;AACP;;AA7JgD;;AAAlD,OAAA,CAAA,OAAA,GAAA,eAAA;;AAgKA,SAAS,MAAT,CAAgB,MAAhB,EAAkD;AACjD,EAAA,MAAM,CAAC,MAAP;AACA;;AAED,SAAS,aAAT,CAAuB,IAAvB,EAAqC,MAArC,EAAoD;AACnD,SAAO,OAAO,CAAE,CAAC,MAAD,IAAW,IAAI,KAAK,EAArB,IAA6B,MAAM,IAAI,IAAI,KAAK,GAAjD,CAAd;AACA;;AAED,SAAS,OAAT,CAAiB,QAAjB,EAAyC;AACxC,SAAO,OAAO,QAAP,KAAoB,QAApB,GAA+B,aAAa,IAAb,CAAkB,QAAlB,CAA/B,GAA6D,KAApE;AACA;;AAED,SAAS,IAAT,CACC,GADD,EAEC,GAAG,IAFJ,EAEW;AAIV,QAAM,GAAG,GAAG,EAAZ;AAGA,MAAI,GAAJ;;AACA,OAAK,GAAL,IAAY,GAAZ,EAAiB;AAChB,QAAI,CAAC,IAAI,CAAC,QAAL,CAAc,GAAd,CAAL,EAAyB;AACxB,MAAA,GAAG,CAAC,GAAD,CAAH,GAAW,GAAG,CAAC,GAAD,CAAd;AACA;AACD;;AACD,SAAO,GAAP;AACA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst net_1 = __importDefault(require(\"net\"));\nconst tls_1 = __importDefault(require(\"tls\"));\nconst url_1 = __importDefault(require(\"url\"));\nconst assert_1 = __importDefault(require(\"assert\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst agent_base_1 = require(\"agent-base\");\nconst parse_proxy_response_1 = __importDefault(require(\"./parse-proxy-response\"));\nconst debug = debug_1.default('https-proxy-agent:agent');\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n *\n * @api public\n */\nclass HttpsProxyAgent extends agent_base_1.Agent {\n    constructor(_opts) {\n        let opts;\n        if (typeof _opts === 'string') {\n            opts = url_1.default.parse(_opts);\n        }\n        else {\n            opts = _opts;\n        }\n        if (!opts) {\n            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n        }\n        debug('creating new HttpsProxyAgent instance: %o', opts);\n        super(opts);\n        const proxy = Object.assign({}, opts);\n        // If `true`, then connect to the proxy server over TLS.\n        // Defaults to `false`.\n        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);\n        // Prefer `hostname` over `host`, and set the `port` if needed.\n        proxy.host = proxy.hostname || proxy.host;\n        if (typeof proxy.port === 'string') {\n            proxy.port = parseInt(proxy.port, 10);\n        }\n        if (!proxy.port && proxy.host) {\n            proxy.port = this.secureProxy ? 443 : 80;\n        }\n        // ALPN is supported by Node.js >= v5.\n        // attempt to negotiate http/1.1 for proxy servers that support http/2\n        if (this.secureProxy && !('ALPNProtocols' in proxy)) {\n            proxy.ALPNProtocols = ['http 1.1'];\n        }\n        if (proxy.host && proxy.path) {\n            // If both a `host` and `path` are specified then it's most likely\n            // the result of a `url.parse()` call... we need to remove the\n            // `path` portion so that `net.connect()` doesn't attempt to open\n            // that as a Unix socket file.\n            delete proxy.path;\n            delete proxy.pathname;\n        }\n        this.proxy = proxy;\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     *\n     * @api protected\n     */\n    callback(req, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { proxy, secureProxy } = this;\n            // Create a socket connection to the proxy server.\n            let socket;\n            if (secureProxy) {\n                debug('Creating `tls.Socket`: %o', proxy);\n                socket = tls_1.default.connect(proxy);\n            }\n            else {\n                debug('Creating `net.Socket`: %o', proxy);\n                socket = net_1.default.connect(proxy);\n            }\n            const headers = Object.assign({}, proxy.headers);\n            const hostname = `${opts.host}:${opts.port}`;\n            let payload = `CONNECT ${hostname} HTTP/1.1\\r\\n`;\n            // Inject the `Proxy-Authorization` header if necessary.\n            if (proxy.auth) {\n                headers['Proxy-Authorization'] = `Basic ${Buffer.from(proxy.auth).toString('base64')}`;\n            }\n            // The `Host` header should only include the port\n            // number when it is not the default port.\n            let { host, port, secureEndpoint } = opts;\n            if (!isDefaultPort(port, secureEndpoint)) {\n                host += `:${port}`;\n            }\n            headers.Host = host;\n            headers.Connection = 'close';\n            for (const name of Object.keys(headers)) {\n                payload += `${name}: ${headers[name]}\\r\\n`;\n            }\n            const proxyResponsePromise = parse_proxy_response_1.default(socket);\n            socket.write(`${payload}\\r\\n`);\n            const { statusCode, buffered } = yield proxyResponsePromise;\n            if (statusCode === 200) {\n                req.once('socket', resume);\n                if (opts.secureEndpoint) {\n                    const servername = opts.servername || opts.host;\n                    if (!servername) {\n                        throw new Error('Could not determine \"servername\"');\n                    }\n                    // The proxy is connecting to a TLS server, so upgrade\n                    // this socket connection to a TLS connection.\n                    debug('Upgrading socket connection to TLS');\n                    return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), { socket,\n                        servername }));\n                }\n                return socket;\n            }\n            // Some other status code that's not 200... need to re-play the HTTP\n            // header \"data\" events onto the socket once the HTTP machinery is\n            // attached so that the node core `http` can parse and handle the\n            // error status code.\n            // Close the original socket, and a new \"fake\" socket is returned\n            // instead, so that the proxy doesn't get the HTTP request\n            // written to it (which may contain `Authorization` headers or other\n            // sensitive data).\n            //\n            // See: https://hackerone.com/reports/541502\n            socket.destroy();\n            const fakeSocket = new net_1.default.Socket();\n            fakeSocket.readable = true;\n            // Need to wait for the \"socket\" event to re-play the \"data\" events.\n            req.once('socket', (s) => {\n                debug('replaying proxy buffer for failed request');\n                assert_1.default(s.listenerCount('data') > 0);\n                // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n                // this point the HTTP module machinery has been hooked up for\n                // the user.\n                s.push(buffered);\n                s.push(null);\n            });\n            return fakeSocket;\n        });\n    }\n}\nexports.default = HttpsProxyAgent;\nfunction resume(socket) {\n    socket.resume();\n}\nfunction isDefaultPort(port, secure) {\n    return Boolean((!secure && port === 80) || (secure && port === 443));\n}\nfunction isHTTPS(protocol) {\n    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for (key in obj) {\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n}\n//# sourceMappingURL=agent.js.map"]},"metadata":{},"sourceType":"script"}