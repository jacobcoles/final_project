{"ast":null,"code":"\"use strict\"; // Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _createForOfIteratorHelper = require(\"/Users/jacobcoles/Desktop/LT2216/final_project/final_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/jacobcoles/Desktop/LT2216/final_project/final_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/jacobcoles/Desktop/LT2216/final_project/final_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\n\nconst querystring = require(\"querystring\");\n\nconst stream = require(\"stream\");\n\nconst formatEcdsa = require(\"ecdsa-sig-formatter\");\n\nconst crypto_1 = require(\"../crypto/crypto\");\n\nconst authclient_1 = require(\"./authclient\");\n\nconst loginticket_1 = require(\"./loginticket\");\n\nvar CodeChallengeMethod;\n\n(function (CodeChallengeMethod) {\n  CodeChallengeMethod[\"Plain\"] = \"plain\";\n  CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\n\nvar CertificateFormat;\n\n(function (CertificateFormat) {\n  CertificateFormat[\"PEM\"] = \"PEM\";\n  CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\n\nclass OAuth2Client extends authclient_1.AuthClient {\n  constructor(optionsOrClientId, clientSecret, redirectUri) {\n    super();\n    this.certificateCache = {};\n    this.certificateExpiry = null;\n    this.certificateCacheFormat = CertificateFormat.PEM;\n    this.refreshTokenPromises = new Map();\n    const opts = optionsOrClientId && typeof optionsOrClientId === 'object' ? optionsOrClientId : {\n      clientId: optionsOrClientId,\n      clientSecret,\n      redirectUri\n    };\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n    this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;\n  }\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n\n\n  generateAuthUrl(opts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n    }\n\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri; // Allow scopes to be passed either as array or a string\n\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  generateCodeVerifier() {\n    // To make the code compatible with browser SubtleCrypto we need to make\n    // this method async.\n    throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n  }\n  /**\n   * Convenience method to automatically generate a code_verifier, and its\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   *\n   * For a full example see:\n   * https://github.com/googleapis/google-auth-library-nodejs/blob/master/samples/oauth2-codeVerifier.js\n   */\n\n\n  generateCodeVerifierAsync() {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var crypto, randomString, codeVerifier, unencodedCodeChallenge, codeChallenge;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            // base64 encoding uses 6 bits per character, and we want to generate128\n            // characters. 6*128/8 = 96.\n            crypto = crypto_1.createCrypto();\n            randomString = crypto.randomBytesBase64(96); // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n            // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n            // swapping out a few chars.\n\n            codeVerifier = randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-'); // Generate the base64 encoded SHA256\n\n            _context.next = 5;\n            return crypto.sha256DigestBase64(codeVerifier);\n\n          case 5:\n            unencodedCodeChallenge = _context.sent;\n            // We need to use base64UrlEncoding instead of standard base64\n            codeChallenge = unencodedCodeChallenge.split('=')[0].replace(/\\+/g, '-').replace(/\\//g, '_');\n            return _context.abrupt(\"return\", {\n              codeVerifier,\n              codeChallenge\n            });\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }))();\n  }\n\n  getToken(codeOrOptions, callback) {\n    const options = typeof codeOrOptions === 'string' ? {\n      code: codeOrOptions\n    } : codeOrOptions;\n\n    if (callback) {\n      this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  getTokenAsync(options) {\n    var _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var url, values, res, tokens;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n            values = {\n              code: options.code,\n              client_id: options.client_id || _this._clientId,\n              client_secret: _this._clientSecret,\n              redirect_uri: options.redirect_uri || _this.redirectUri,\n              grant_type: 'authorization_code',\n              code_verifier: options.codeVerifier\n            };\n            _context2.next = 4;\n            return _this.transporter.request({\n              method: 'POST',\n              url,\n              data: querystring.stringify(values),\n              headers: {\n                'Content-Type': 'application/x-www-form-urlencoded'\n              }\n            });\n\n          case 4:\n            res = _context2.sent;\n            tokens = res.data;\n\n            if (res.data && res.data.expires_in) {\n              tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n              delete tokens.expires_in;\n            }\n\n            _this.emit('tokens', tokens);\n\n            return _context2.abrupt(\"return\", {\n              tokens,\n              res\n            });\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }))();\n  }\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n\n\n  refreshToken(refreshToken) {\n    var _this2 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var p;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            if (refreshToken) {\n              _context3.next = 2;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", _this2.refreshTokenNoCache(refreshToken));\n\n          case 2:\n            if (!_this2.refreshTokenPromises.has(refreshToken)) {\n              _context3.next = 4;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", _this2.refreshTokenPromises.get(refreshToken));\n\n          case 4:\n            p = _this2.refreshTokenNoCache(refreshToken).then(r => {\n              _this2.refreshTokenPromises.delete(refreshToken);\n\n              return r;\n            }, e => {\n              _this2.refreshTokenPromises.delete(refreshToken);\n\n              throw e;\n            });\n\n            _this2.refreshTokenPromises.set(refreshToken, p);\n\n            return _context3.abrupt(\"return\", p);\n\n          case 7:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }))();\n  }\n\n  refreshTokenNoCache(refreshToken) {\n    var _this3 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      var url, data, res, tokens;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            if (refreshToken) {\n              _context4.next = 2;\n              break;\n            }\n\n            throw new Error('No refresh token is set.');\n\n          case 2:\n            url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n            data = {\n              refresh_token: refreshToken,\n              client_id: _this3._clientId,\n              client_secret: _this3._clientSecret,\n              grant_type: 'refresh_token'\n            }; // request for new token\n\n            _context4.next = 6;\n            return _this3.transporter.request({\n              method: 'POST',\n              url,\n              data: querystring.stringify(data),\n              headers: {\n                'Content-Type': 'application/x-www-form-urlencoded'\n              }\n            });\n\n          case 6:\n            res = _context4.sent;\n            tokens = res.data; // TODO: de-duplicate this code from a few spots\n\n            if (res.data && res.data.expires_in) {\n              tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n              delete tokens.expires_in;\n            }\n\n            _this3.emit('tokens', tokens);\n\n            return _context4.abrupt(\"return\", {\n              tokens,\n              res\n            });\n\n          case 11:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }))();\n  }\n\n  refreshAccessToken(callback) {\n    if (callback) {\n      this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  refreshAccessTokenAsync() {\n    var _this4 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n      var r, tokens;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return _this4.refreshToken(_this4.credentials.refresh_token);\n\n          case 2:\n            r = _context5.sent;\n            tokens = r.tokens;\n            tokens.refresh_token = _this4.credentials.refresh_token;\n            _this4.credentials = tokens;\n            return _context5.abrupt(\"return\", {\n              credentials: _this4.credentials,\n              res: r.res\n            });\n\n          case 7:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }))();\n  }\n\n  getAccessToken(callback) {\n    if (callback) {\n      this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  getAccessTokenAsync() {\n    var _this5 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n      var shouldRefresh, r;\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            shouldRefresh = !_this5.credentials.access_token || _this5.isTokenExpiring();\n\n            if (!shouldRefresh) {\n              _context6.next = 12;\n              break;\n            }\n\n            if (_this5.credentials.refresh_token) {\n              _context6.next = 4;\n              break;\n            }\n\n            throw new Error('No refresh token is set.');\n\n          case 4:\n            _context6.next = 6;\n            return _this5.refreshAccessTokenAsync();\n\n          case 6:\n            r = _context6.sent;\n\n            if (!(!r.credentials || r.credentials && !r.credentials.access_token)) {\n              _context6.next = 9;\n              break;\n            }\n\n            throw new Error('Could not refresh access token.');\n\n          case 9:\n            return _context6.abrupt(\"return\", {\n              token: r.credentials.access_token,\n              res: r.res\n            });\n\n          case 12:\n            return _context6.abrupt(\"return\", {\n              token: _this5.credentials.access_token\n            });\n\n          case 13:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }))();\n  }\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer <access_token_value>' }\n   * @param url The optional url being authorized\n   */\n\n\n  getRequestHeaders(url) {\n    var _this6 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n      var headers;\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return _this6.getRequestMetadataAsync(url);\n\n          case 2:\n            headers = _context7.sent.headers;\n            return _context7.abrupt(\"return\", headers);\n\n          case 4:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7);\n    }))();\n  }\n\n  getRequestMetadataAsync( // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  url) {\n    var _this7 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n      var thisCreds, headers, r, tokens, e, credentials;\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            thisCreds = _this7.credentials;\n\n            if (!(!thisCreds.access_token && !thisCreds.refresh_token && !_this7.apiKey)) {\n              _context8.next = 3;\n              break;\n            }\n\n            throw new Error('No access, refresh token or API key is set.');\n\n          case 3:\n            if (!(thisCreds.access_token && !_this7.isTokenExpiring())) {\n              _context8.next = 7;\n              break;\n            }\n\n            thisCreds.token_type = thisCreds.token_type || 'Bearer';\n            headers = {\n              Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n            };\n            return _context8.abrupt(\"return\", {\n              headers: _this7.addSharedMetadataHeaders(headers)\n            });\n\n          case 7:\n            if (!_this7.apiKey) {\n              _context8.next = 9;\n              break;\n            }\n\n            return _context8.abrupt(\"return\", {\n              headers: {\n                'X-Goog-Api-Key': _this7.apiKey\n              }\n            });\n\n          case 9:\n            r = null;\n            tokens = null;\n            _context8.prev = 11;\n            _context8.next = 14;\n            return _this7.refreshToken(thisCreds.refresh_token);\n\n          case 14:\n            r = _context8.sent;\n            tokens = r.tokens;\n            _context8.next = 23;\n            break;\n\n          case 18:\n            _context8.prev = 18;\n            _context8.t0 = _context8[\"catch\"](11);\n            e = _context8.t0;\n\n            if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n              e.message = \"Could not refresh access token: \".concat(e.message);\n            }\n\n            throw e;\n\n          case 23:\n            credentials = _this7.credentials;\n            credentials.token_type = credentials.token_type || 'Bearer';\n            tokens.refresh_token = credentials.refresh_token;\n            _this7.credentials = tokens;\n            headers = {\n              Authorization: credentials.token_type + ' ' + tokens.access_token\n            };\n            return _context8.abrupt(\"return\", {\n              headers: _this7.addSharedMetadataHeaders(headers),\n              res: r.res\n            });\n\n          case 29:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, _callee8, null, [[11, 18]]);\n    }))();\n  }\n  /**\n   * Generates an URL to revoke the given token.\n   * @param token The existing token to be revoked.\n   */\n\n\n  static getRevokeTokenUrl(token) {\n    const parameters = querystring.stringify({\n      token\n    });\n    return \"\".concat(OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_, \"?\").concat(parameters);\n  }\n\n  revokeToken(token, callback) {\n    const opts = {\n      url: OAuth2Client.getRevokeTokenUrl(token),\n      method: 'POST'\n    };\n\n    if (callback) {\n      this.transporter.request(opts).then(r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n  revokeCredentials(callback) {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  revokeCredentialsAsync() {\n    var _this8 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n      var token;\n      return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n        while (1) switch (_context9.prev = _context9.next) {\n          case 0:\n            token = _this8.credentials.access_token;\n            _this8.credentials = {};\n\n            if (!token) {\n              _context9.next = 6;\n              break;\n            }\n\n            return _context9.abrupt(\"return\", _this8.revokeToken(token));\n\n          case 6:\n            throw new Error('No access token to revoke.');\n\n          case 7:\n          case \"end\":\n            return _context9.stop();\n        }\n      }, _callee9);\n    }))();\n  }\n\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  requestAsync(opts, retry = false) {\n    var _this9 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n      var r2, r, res, statusCode, mayRequireRefresh, isReadableStream, isAuthErr;\n      return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n        while (1) switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.prev = 0;\n            _context10.next = 3;\n            return _this9.getRequestMetadataAsync(opts.url);\n\n          case 3:\n            r = _context10.sent;\n            opts.headers = opts.headers || {};\n\n            if (r.headers && r.headers['x-goog-user-project']) {\n              opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];\n            }\n\n            if (r.headers && r.headers.Authorization) {\n              opts.headers.Authorization = r.headers.Authorization;\n            }\n\n            if (_this9.apiKey) {\n              opts.headers['X-Goog-Api-Key'] = _this9.apiKey;\n            }\n\n            _context10.next = 10;\n            return _this9.transporter.request(opts);\n\n          case 10:\n            r2 = _context10.sent;\n            _context10.next = 26;\n            break;\n\n          case 13:\n            _context10.prev = 13;\n            _context10.t0 = _context10[\"catch\"](0);\n            res = _context10.t0.response;\n\n            if (!res) {\n              _context10.next = 25;\n              break;\n            }\n\n            statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n            // - We haven't already retried.  It only makes sense to retry once.\n            // - The response was a 401 or a 403\n            // - The request didn't send a readableStream\n            // - An access_token and refresh_token were available, but either no\n            //   expiry_date was available or the forceRefreshOnFailure flag is set.\n            //   The absent expiry_date case can happen when developers stash the\n            //   access_token and refresh_token for later use, but the access_token\n            //   fails on the first try because it's expired. Some developers may\n            //   choose to enable forceRefreshOnFailure to mitigate time-related\n            //   errors.\n\n            mayRequireRefresh = _this9.credentials && _this9.credentials.access_token && _this9.credentials.refresh_token && (!_this9.credentials.expiry_date || _this9.forceRefreshOnFailure);\n            isReadableStream = res.config.data instanceof stream.Readable;\n            isAuthErr = statusCode === 401 || statusCode === 403;\n\n            if (!(!retry && isAuthErr && !isReadableStream && mayRequireRefresh)) {\n              _context10.next = 25;\n              break;\n            }\n\n            _context10.next = 24;\n            return _this9.refreshAccessTokenAsync();\n\n          case 24:\n            return _context10.abrupt(\"return\", _this9.requestAsync(opts, true));\n\n          case 25:\n            throw _context10.t0;\n\n          case 26:\n            return _context10.abrupt(\"return\", r2);\n\n          case 27:\n          case \"end\":\n            return _context10.stop();\n        }\n      }, _callee10, null, [[0, 13]]);\n    }))();\n  }\n\n  verifyIdToken(options, callback) {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  verifyIdTokenAsync(options) {\n    var _this10 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n      var response, login;\n      return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n        while (1) switch (_context11.prev = _context11.next) {\n          case 0:\n            if (options.idToken) {\n              _context11.next = 2;\n              break;\n            }\n\n            throw new Error('The verifyIdToken method requires an ID Token');\n\n          case 2:\n            _context11.next = 4;\n            return _this10.getFederatedSignonCertsAsync();\n\n          case 4:\n            response = _context11.sent;\n            _context11.next = 7;\n            return _this10.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n\n          case 7:\n            login = _context11.sent;\n            return _context11.abrupt(\"return\", login);\n\n          case 9:\n          case \"end\":\n            return _context11.stop();\n        }\n      }, _callee11);\n    }))();\n  }\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n\n\n  getTokenInfo(accessToken) {\n    var _this11 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n      var _yield$_this11$transp, data, info;\n\n      return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n        while (1) switch (_context12.prev = _context12.next) {\n          case 0:\n            _context12.next = 2;\n            return _this11.transporter.request({\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                Authorization: \"Bearer \".concat(accessToken)\n              },\n              url: OAuth2Client.GOOGLE_TOKEN_INFO_URL\n            });\n\n          case 2:\n            _yield$_this11$transp = _context12.sent;\n            data = _yield$_this11$transp.data;\n            info = Object.assign({\n              expiry_date: new Date().getTime() + data.expires_in * 1000,\n              scopes: data.scope.split(' ')\n            }, data);\n            delete info.expires_in;\n            delete info.scope;\n            return _context12.abrupt(\"return\", info);\n\n          case 8:\n          case \"end\":\n            return _context12.stop();\n        }\n      }, _callee12);\n    }))();\n  }\n\n  getFederatedSignonCerts(callback) {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  getFederatedSignonCertsAsync() {\n    var _this12 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n      var nowTime, format, res, url, cacheControl, cacheAge, pattern, regexResult, certificates, _iterator, _step, key, now;\n\n      return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n        while (1) switch (_context13.prev = _context13.next) {\n          case 0:\n            nowTime = new Date().getTime();\n            format = crypto_1.hasBrowserCrypto() ? CertificateFormat.JWK : CertificateFormat.PEM;\n\n            if (!(_this12.certificateExpiry && nowTime < _this12.certificateExpiry.getTime() && _this12.certificateCacheFormat === format)) {\n              _context13.next = 4;\n              break;\n            }\n\n            return _context13.abrupt(\"return\", {\n              certs: _this12.certificateCache,\n              format\n            });\n\n          case 4:\n            _context13.t0 = format;\n            _context13.next = _context13.t0 === CertificateFormat.PEM ? 7 : _context13.t0 === CertificateFormat.JWK ? 9 : 11;\n            break;\n\n          case 7:\n            url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n            return _context13.abrupt(\"break\", 12);\n\n          case 9:\n            url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n            return _context13.abrupt(\"break\", 12);\n\n          case 11:\n            throw new Error(\"Unsupported certificate format \".concat(format));\n\n          case 12:\n            _context13.prev = 12;\n            _context13.next = 15;\n            return _this12.transporter.request({\n              url\n            });\n\n          case 15:\n            res = _context13.sent;\n            _context13.next = 22;\n            break;\n\n          case 18:\n            _context13.prev = 18;\n            _context13.t1 = _context13[\"catch\"](12);\n            _context13.t1.message = \"Failed to retrieve verification certificates: \".concat(_context13.t1.message);\n            throw _context13.t1;\n\n          case 22:\n            cacheControl = res ? res.headers['cache-control'] : undefined;\n            cacheAge = -1;\n\n            if (cacheControl) {\n              pattern = new RegExp('max-age=([0-9]*)');\n              regexResult = pattern.exec(cacheControl);\n\n              if (regexResult && regexResult.length === 2) {\n                // Cache results with max-age (in seconds)\n                cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n              }\n            }\n\n            certificates = {};\n            _context13.t2 = format;\n            _context13.next = _context13.t2 === CertificateFormat.PEM ? 29 : _context13.t2 === CertificateFormat.JWK ? 31 : 34;\n            break;\n\n          case 29:\n            certificates = res.data;\n            return _context13.abrupt(\"break\", 35);\n\n          case 31:\n            _iterator = _createForOfIteratorHelper(res.data.keys);\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                key = _step.value;\n                certificates[key.kid] = key;\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            return _context13.abrupt(\"break\", 35);\n\n          case 34:\n            throw new Error(\"Unsupported certificate format \".concat(format));\n\n          case 35:\n            now = new Date();\n            _this12.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n            _this12.certificateCache = certificates;\n            _this12.certificateCacheFormat = format;\n            return _context13.abrupt(\"return\", {\n              certs: certificates,\n              format,\n              res\n            });\n\n          case 40:\n          case \"end\":\n            return _context13.stop();\n        }\n      }, _callee13, null, [[12, 18]]);\n    }))();\n  }\n\n  getIapPublicKeys(callback) {\n    if (callback) {\n      this.getIapPublicKeysAsync().then(r => callback(null, r.pubkeys, r.res), callback);\n    } else {\n      return this.getIapPublicKeysAsync();\n    }\n  }\n\n  getIapPublicKeysAsync() {\n    var _this13 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n      var res, url;\n      return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n        while (1) switch (_context14.prev = _context14.next) {\n          case 0:\n            url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;\n            _context14.prev = 1;\n            _context14.next = 4;\n            return _this13.transporter.request({\n              url\n            });\n\n          case 4:\n            res = _context14.sent;\n            _context14.next = 11;\n            break;\n\n          case 7:\n            _context14.prev = 7;\n            _context14.t0 = _context14[\"catch\"](1);\n            _context14.t0.message = \"Failed to retrieve verification certificates: \".concat(_context14.t0.message);\n            throw _context14.t0;\n\n          case 11:\n            return _context14.abrupt(\"return\", {\n              pubkeys: res.data,\n              res\n            });\n\n          case 12:\n          case \"end\":\n            return _context14.stop();\n        }\n      }, _callee14, null, [[1, 7]]);\n    }))();\n  }\n\n  verifySignedJwtWithCerts() {\n    // To make the code compatible with browser SubtleCrypto we need to make\n    // this method async.\n    throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n  }\n  /**\n   * Verify the id token is signed with the correct certificate\n   * and is from the correct audience.\n   * @param jwt The jwt to verify (The ID Token in this case).\n   * @param certs The array of certs to test the jwt against.\n   * @param requiredAudience The audience to test the jwt against.\n   * @param issuers The allowed issuers of the jwt (Optional).\n   * @param maxExpiry The max expiry the certificate can be (Optional).\n   * @return Returns a promise resolving to LoginTicket on verification.\n   */\n\n\n  verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n      var crypto, segments, signed, signature, envelope, payload, cert, verified, iat, exp, now, earliest, latest, aud, audVerified;\n      return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n        while (1) switch (_context15.prev = _context15.next) {\n          case 0:\n            crypto = crypto_1.createCrypto();\n\n            if (!maxExpiry) {\n              maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n            }\n\n            segments = jwt.split('.');\n\n            if (!(segments.length !== 3)) {\n              _context15.next = 5;\n              break;\n            }\n\n            throw new Error('Wrong number of segments in token: ' + jwt);\n\n          case 5:\n            signed = segments[0] + '.' + segments[1];\n            signature = segments[2];\n            _context15.prev = 7;\n            envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n            _context15.next = 15;\n            break;\n\n          case 11:\n            _context15.prev = 11;\n            _context15.t0 = _context15[\"catch\"](7);\n            _context15.t0.message = \"Can't parse token envelope: \".concat(segments[0], \"': \").concat(_context15.t0.message);\n            throw _context15.t0;\n\n          case 15:\n            if (envelope) {\n              _context15.next = 17;\n              break;\n            }\n\n            throw new Error(\"Can't parse token envelope: \" + segments[0]);\n\n          case 17:\n            _context15.prev = 17;\n            payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n            _context15.next = 25;\n            break;\n\n          case 21:\n            _context15.prev = 21;\n            _context15.t1 = _context15[\"catch\"](17);\n            _context15.t1.message = \"Can't parse token payload '\".concat(segments[0]);\n            throw _context15.t1;\n\n          case 25:\n            if (payload) {\n              _context15.next = 27;\n              break;\n            }\n\n            throw new Error(\"Can't parse token payload: \" + segments[1]);\n\n          case 27:\n            if (Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n              _context15.next = 29;\n              break;\n            }\n\n            throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n\n          case 29:\n            cert = certs[envelope.kid];\n\n            if (envelope.alg === 'ES256') {\n              signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\n            }\n\n            _context15.next = 33;\n            return crypto.verify(cert, signed, signature);\n\n          case 33:\n            verified = _context15.sent;\n\n            if (verified) {\n              _context15.next = 36;\n              break;\n            }\n\n            throw new Error('Invalid token signature: ' + jwt);\n\n          case 36:\n            if (payload.iat) {\n              _context15.next = 38;\n              break;\n            }\n\n            throw new Error('No issue time in token: ' + JSON.stringify(payload));\n\n          case 38:\n            if (payload.exp) {\n              _context15.next = 40;\n              break;\n            }\n\n            throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n\n          case 40:\n            iat = Number(payload.iat);\n\n            if (!isNaN(iat)) {\n              _context15.next = 43;\n              break;\n            }\n\n            throw new Error('iat field using invalid format');\n\n          case 43:\n            exp = Number(payload.exp);\n\n            if (!isNaN(exp)) {\n              _context15.next = 46;\n              break;\n            }\n\n            throw new Error('exp field using invalid format');\n\n          case 46:\n            now = new Date().getTime() / 1000;\n\n            if (!(exp >= now + maxExpiry)) {\n              _context15.next = 49;\n              break;\n            }\n\n            throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n\n          case 49:\n            earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n            latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n            if (!(now < earliest)) {\n              _context15.next = 53;\n              break;\n            }\n\n            throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));\n\n          case 53:\n            if (!(now > latest)) {\n              _context15.next = 55;\n              break;\n            }\n\n            throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));\n\n          case 55:\n            if (!(issuers && issuers.indexOf(payload.iss) < 0)) {\n              _context15.next = 57;\n              break;\n            }\n\n            throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);\n\n          case 57:\n            if (!(typeof requiredAudience !== 'undefined' && requiredAudience !== null)) {\n              _context15.next = 63;\n              break;\n            }\n\n            aud = payload.aud;\n            audVerified = false; // If the requiredAudience is an array, check if it contains token\n            // audience\n\n            if (requiredAudience.constructor === Array) {\n              audVerified = requiredAudience.indexOf(aud) > -1;\n            } else {\n              audVerified = aud === requiredAudience;\n            }\n\n            if (audVerified) {\n              _context15.next = 63;\n              break;\n            }\n\n            throw new Error('Wrong recipient, payload audience != requiredAudience');\n\n          case 63:\n            return _context15.abrupt(\"return\", new loginticket_1.LoginTicket(envelope, payload));\n\n          case 64:\n          case \"end\":\n            return _context15.stop();\n        }\n      }, _callee15, null, [[7, 11], [17, 21]]);\n    }))();\n  }\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n\n\n  isTokenExpiring() {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n  }\n\n}\n\nexports.OAuth2Client = OAuth2Client;\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates in PEM format.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\n\nOAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';\n/**\n * Clock skew - five minutes in seconds\n */\n\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\n\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\n\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];","map":{"version":3,"sources":["/Users/jacobcoles/Desktop/LT2216/final_project/final_project/node_modules/google-auth-library/build/src/auth/oauth2client.js"],"names":["Object","defineProperty","exports","value","OAuth2Client","CertificateFormat","CodeChallengeMethod","querystring","require","stream","formatEcdsa","crypto_1","authclient_1","loginticket_1","AuthClient","constructor","optionsOrClientId","clientSecret","redirectUri","certificateCache","certificateExpiry","certificateCacheFormat","PEM","refreshTokenPromises","Map","opts","clientId","_clientId","_clientSecret","eagerRefreshThresholdMillis","forceRefreshOnFailure","generateAuthUrl","code_challenge_method","code_challenge","Error","response_type","client_id","redirect_uri","scope","Array","join","rootUrl","GOOGLE_OAUTH2_AUTH_BASE_URL_","stringify","generateCodeVerifier","generateCodeVerifierAsync","crypto","createCrypto","randomString","randomBytesBase64","codeVerifier","replace","sha256DigestBase64","unencodedCodeChallenge","codeChallenge","split","getToken","codeOrOptions","callback","options","code","getTokenAsync","then","r","tokens","res","e","response","url","GOOGLE_OAUTH2_TOKEN_URL_","values","client_secret","grant_type","code_verifier","transporter","request","method","data","headers","expires_in","expiry_date","Date","getTime","emit","refreshToken","refreshTokenNoCache","has","get","p","delete","set","refresh_token","refreshAccessToken","refreshAccessTokenAsync","credentials","getAccessToken","getAccessTokenAsync","token","shouldRefresh","access_token","isTokenExpiring","getRequestHeaders","getRequestMetadataAsync","thisCreds","apiKey","token_type","Authorization","addSharedMetadataHeaders","status","message","getRevokeTokenUrl","parameters","GOOGLE_OAUTH2_REVOKE_URL_","revokeToken","revokeCredentials","revokeCredentialsAsync","requestAsync","retry","r2","statusCode","mayRequireRefresh","isReadableStream","config","Readable","isAuthErr","verifyIdToken","verifyIdTokenAsync","idToken","getFederatedSignonCertsAsync","verifySignedJwtWithCertsAsync","certs","audience","ISSUERS_","maxExpiry","login","getTokenInfo","accessToken","GOOGLE_TOKEN_INFO_URL","info","assign","scopes","getFederatedSignonCerts","nowTime","format","hasBrowserCrypto","JWK","GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_","GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_","cacheControl","undefined","cacheAge","pattern","RegExp","regexResult","exec","length","Number","certificates","keys","key","kid","now","getIapPublicKeys","getIapPublicKeysAsync","pubkeys","GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_","verifySignedJwtWithCerts","jwt","requiredAudience","issuers","MAX_TOKEN_LIFETIME_SECS_","segments","signed","signature","envelope","JSON","parse","decodeBase64StringUtf8","payload","prototype","hasOwnProperty","call","cert","alg","joseToDer","toString","verify","verified","iat","exp","isNaN","earliest","CLOCK_SKEW_SECS_","latest","indexOf","iss","aud","audVerified","LoginTicket","expiryDate"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\nconst querystring = require(\"querystring\");\nconst stream = require(\"stream\");\nconst formatEcdsa = require(\"ecdsa-sig-formatter\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst authclient_1 = require(\"./authclient\");\nconst loginticket_1 = require(\"./loginticket\");\nvar CodeChallengeMethod;\n(function (CodeChallengeMethod) {\n    CodeChallengeMethod[\"Plain\"] = \"plain\";\n    CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function (CertificateFormat) {\n    CertificateFormat[\"PEM\"] = \"PEM\";\n    CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\nclass OAuth2Client extends authclient_1.AuthClient {\n    constructor(optionsOrClientId, clientSecret, redirectUri) {\n        super();\n        this.certificateCache = {};\n        this.certificateExpiry = null;\n        this.certificateCacheFormat = CertificateFormat.PEM;\n        this.refreshTokenPromises = new Map();\n        const opts = optionsOrClientId && typeof optionsOrClientId === 'object'\n            ? optionsOrClientId\n            : { clientId: optionsOrClientId, clientSecret, redirectUri };\n        this._clientId = opts.clientId;\n        this._clientSecret = opts.clientSecret;\n        this.redirectUri = opts.redirectUri;\n        this.eagerRefreshThresholdMillis =\n            opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n        this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;\n    }\n    /**\n     * Generates URL for consent page landing.\n     * @param opts Options.\n     * @return URL to consent page.\n     */\n    generateAuthUrl(opts = {}) {\n        if (opts.code_challenge_method && !opts.code_challenge) {\n            throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n        }\n        opts.response_type = opts.response_type || 'code';\n        opts.client_id = opts.client_id || this._clientId;\n        opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n        // Allow scopes to be passed either as array or a string\n        if (opts.scope instanceof Array) {\n            opts.scope = opts.scope.join(' ');\n        }\n        const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n        return rootUrl + '?' + querystring.stringify(opts);\n    }\n    generateCodeVerifier() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and its\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     *\n     * For a full example see:\n     * https://github.com/googleapis/google-auth-library-nodejs/blob/master/samples/oauth2-codeVerifier.js\n     */\n    async generateCodeVerifierAsync() {\n        // base64 encoding uses 6 bits per character, and we want to generate128\n        // characters. 6*128/8 = 96.\n        const crypto = crypto_1.createCrypto();\n        const randomString = crypto.randomBytesBase64(96);\n        // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n        // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n        // swapping out a few chars.\n        const codeVerifier = randomString\n            .replace(/\\+/g, '~')\n            .replace(/=/g, '_')\n            .replace(/\\//g, '-');\n        // Generate the base64 encoded SHA256\n        const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier);\n        // We need to use base64UrlEncoding instead of standard base64\n        const codeChallenge = unencodedCodeChallenge\n            .split('=')[0]\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_');\n        return { codeVerifier, codeChallenge };\n    }\n    getToken(codeOrOptions, callback) {\n        const options = typeof codeOrOptions === 'string' ? { code: codeOrOptions } : codeOrOptions;\n        if (callback) {\n            this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n        }\n        else {\n            return this.getTokenAsync(options);\n        }\n    }\n    async getTokenAsync(options) {\n        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n        const values = {\n            code: options.code,\n            client_id: options.client_id || this._clientId,\n            client_secret: this._clientSecret,\n            redirect_uri: options.redirect_uri || this.redirectUri,\n            grant_type: 'authorization_code',\n            code_verifier: options.codeVerifier,\n        };\n        const res = await this.transporter.request({\n            method: 'POST',\n            url,\n            data: querystring.stringify(values),\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n        });\n        const tokens = res.data;\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit('tokens', tokens);\n        return { tokens, res };\n    }\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */\n    async refreshToken(refreshToken) {\n        if (!refreshToken) {\n            return this.refreshTokenNoCache(refreshToken);\n        }\n        // If a request to refresh using the same token has started,\n        // return the same promise.\n        if (this.refreshTokenPromises.has(refreshToken)) {\n            return this.refreshTokenPromises.get(refreshToken);\n        }\n        const p = this.refreshTokenNoCache(refreshToken).then(r => {\n            this.refreshTokenPromises.delete(refreshToken);\n            return r;\n        }, e => {\n            this.refreshTokenPromises.delete(refreshToken);\n            throw e;\n        });\n        this.refreshTokenPromises.set(refreshToken, p);\n        return p;\n    }\n    async refreshTokenNoCache(refreshToken) {\n        if (!refreshToken) {\n            throw new Error('No refresh token is set.');\n        }\n        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n        const data = {\n            refresh_token: refreshToken,\n            client_id: this._clientId,\n            client_secret: this._clientSecret,\n            grant_type: 'refresh_token',\n        };\n        // request for new token\n        const res = await this.transporter.request({\n            method: 'POST',\n            url,\n            data: querystring.stringify(data),\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n        });\n        const tokens = res.data;\n        // TODO: de-duplicate this code from a few spots\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit('tokens', tokens);\n        return { tokens, res };\n    }\n    refreshAccessToken(callback) {\n        if (callback) {\n            this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n        }\n        else {\n            return this.refreshAccessTokenAsync();\n        }\n    }\n    async refreshAccessTokenAsync() {\n        const r = await this.refreshToken(this.credentials.refresh_token);\n        const tokens = r.tokens;\n        tokens.refresh_token = this.credentials.refresh_token;\n        this.credentials = tokens;\n        return { credentials: this.credentials, res: r.res };\n    }\n    getAccessToken(callback) {\n        if (callback) {\n            this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n        }\n        else {\n            return this.getAccessTokenAsync();\n        }\n    }\n    async getAccessTokenAsync() {\n        const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n        if (shouldRefresh) {\n            if (!this.credentials.refresh_token) {\n                throw new Error('No refresh token is set.');\n            }\n            const r = await this.refreshAccessTokenAsync();\n            if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n                throw new Error('Could not refresh access token.');\n            }\n            return { token: r.credentials.access_token, res: r.res };\n        }\n        else {\n            return { token: this.credentials.access_token };\n        }\n    }\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     * @param url The optional url being authorized\n     */\n    async getRequestHeaders(url) {\n        const headers = (await this.getRequestMetadataAsync(url)).headers;\n        return headers;\n    }\n    async getRequestMetadataAsync(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    url) {\n        const thisCreds = this.credentials;\n        if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n            throw new Error('No access, refresh token or API key is set.');\n        }\n        if (thisCreds.access_token && !this.isTokenExpiring()) {\n            thisCreds.token_type = thisCreds.token_type || 'Bearer';\n            const headers = {\n                Authorization: thisCreds.token_type + ' ' + thisCreds.access_token,\n            };\n            return { headers: this.addSharedMetadataHeaders(headers) };\n        }\n        if (this.apiKey) {\n            return { headers: { 'X-Goog-Api-Key': this.apiKey } };\n        }\n        let r = null;\n        let tokens = null;\n        try {\n            r = await this.refreshToken(thisCreds.refresh_token);\n            tokens = r.tokens;\n        }\n        catch (err) {\n            const e = err;\n            if (e.response &&\n                (e.response.status === 403 || e.response.status === 404)) {\n                e.message = `Could not refresh access token: ${e.message}`;\n            }\n            throw e;\n        }\n        const credentials = this.credentials;\n        credentials.token_type = credentials.token_type || 'Bearer';\n        tokens.refresh_token = credentials.refresh_token;\n        this.credentials = tokens;\n        const headers = {\n            Authorization: credentials.token_type + ' ' + tokens.access_token,\n        };\n        return { headers: this.addSharedMetadataHeaders(headers), res: r.res };\n    }\n    /**\n     * Generates an URL to revoke the given token.\n     * @param token The existing token to be revoked.\n     */\n    static getRevokeTokenUrl(token) {\n        const parameters = querystring.stringify({ token });\n        return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;\n    }\n    revokeToken(token, callback) {\n        const opts = {\n            url: OAuth2Client.getRevokeTokenUrl(token),\n            method: 'POST',\n        };\n        if (callback) {\n            this.transporter\n                .request(opts)\n                .then(r => callback(null, r), callback);\n        }\n        else {\n            return this.transporter.request(opts);\n        }\n    }\n    revokeCredentials(callback) {\n        if (callback) {\n            this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n        }\n        else {\n            return this.revokeCredentialsAsync();\n        }\n    }\n    async revokeCredentialsAsync() {\n        const token = this.credentials.access_token;\n        this.credentials = {};\n        if (token) {\n            return this.revokeToken(token);\n        }\n        else {\n            throw new Error('No access token to revoke.');\n        }\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    async requestAsync(opts, retry = false) {\n        let r2;\n        try {\n            const r = await this.getRequestMetadataAsync(opts.url);\n            opts.headers = opts.headers || {};\n            if (r.headers && r.headers['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];\n            }\n            if (r.headers && r.headers.Authorization) {\n                opts.headers.Authorization = r.headers.Authorization;\n            }\n            if (this.apiKey) {\n                opts.headers['X-Goog-Api-Key'] = this.apiKey;\n            }\n            r2 = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - An access_token and refresh_token were available, but either no\n                //   expiry_date was available or the forceRefreshOnFailure flag is set.\n                //   The absent expiry_date case can happen when developers stash the\n                //   access_token and refresh_token for later use, but the access_token\n                //   fails on the first try because it's expired. Some developers may\n                //   choose to enable forceRefreshOnFailure to mitigate time-related\n                //   errors.\n                const mayRequireRefresh = this.credentials &&\n                    this.credentials.access_token &&\n                    this.credentials.refresh_token &&\n                    (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n                    await this.refreshAccessTokenAsync();\n                    return this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return r2;\n    }\n    verifyIdToken(options, callback) {\n        // This function used to accept two arguments instead of an options object.\n        // Check the types to help users upgrade with less pain.\n        // This check can be removed after a 2.0 release.\n        if (callback && typeof callback !== 'function') {\n            throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n        }\n        if (callback) {\n            this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n        }\n        else {\n            return this.verifyIdTokenAsync(options);\n        }\n    }\n    async verifyIdTokenAsync(options) {\n        if (!options.idToken) {\n            throw new Error('The verifyIdToken method requires an ID Token');\n        }\n        const response = await this.getFederatedSignonCertsAsync();\n        const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n        return login;\n    }\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */\n    async getTokenInfo(accessToken) {\n        const { data } = await this.transporter.request({\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                Authorization: `Bearer ${accessToken}`,\n            },\n            url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n        });\n        const info = Object.assign({\n            expiry_date: new Date().getTime() + data.expires_in * 1000,\n            scopes: data.scope.split(' '),\n        }, data);\n        delete info.expires_in;\n        delete info.scope;\n        return info;\n    }\n    getFederatedSignonCerts(callback) {\n        if (callback) {\n            this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n        }\n        else {\n            return this.getFederatedSignonCertsAsync();\n        }\n    }\n    async getFederatedSignonCertsAsync() {\n        const nowTime = new Date().getTime();\n        const format = crypto_1.hasBrowserCrypto()\n            ? CertificateFormat.JWK\n            : CertificateFormat.PEM;\n        if (this.certificateExpiry &&\n            nowTime < this.certificateExpiry.getTime() &&\n            this.certificateCacheFormat === format) {\n            return { certs: this.certificateCache, format };\n        }\n        let res;\n        let url;\n        switch (format) {\n            case CertificateFormat.PEM:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n                break;\n            case CertificateFormat.JWK:\n                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        try {\n            res = await this.transporter.request({ url });\n        }\n        catch (e) {\n            e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            throw e;\n        }\n        const cacheControl = res ? res.headers['cache-control'] : undefined;\n        let cacheAge = -1;\n        if (cacheControl) {\n            const pattern = new RegExp('max-age=([0-9]*)');\n            const regexResult = pattern.exec(cacheControl);\n            if (regexResult && regexResult.length === 2) {\n                // Cache results with max-age (in seconds)\n                cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n            }\n        }\n        let certificates = {};\n        switch (format) {\n            case CertificateFormat.PEM:\n                certificates = res.data;\n                break;\n            case CertificateFormat.JWK:\n                for (const key of res.data.keys) {\n                    certificates[key.kid] = key;\n                }\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        const now = new Date();\n        this.certificateExpiry =\n            cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n        this.certificateCache = certificates;\n        this.certificateCacheFormat = format;\n        return { certs: certificates, format, res };\n    }\n    getIapPublicKeys(callback) {\n        if (callback) {\n            this.getIapPublicKeysAsync().then(r => callback(null, r.pubkeys, r.res), callback);\n        }\n        else {\n            return this.getIapPublicKeysAsync();\n        }\n    }\n    async getIapPublicKeysAsync() {\n        let res;\n        const url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;\n        try {\n            res = await this.transporter.request({ url });\n        }\n        catch (e) {\n            e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            throw e;\n        }\n        return { pubkeys: res.data, res };\n    }\n    verifySignedJwtWithCerts() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a promise resolving to LoginTicket on verification.\n     */\n    async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n        const crypto = crypto_1.createCrypto();\n        if (!maxExpiry) {\n            maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n        }\n        const segments = jwt.split('.');\n        if (segments.length !== 3) {\n            throw new Error('Wrong number of segments in token: ' + jwt);\n        }\n        const signed = segments[0] + '.' + segments[1];\n        let signature = segments[2];\n        let envelope;\n        let payload;\n        try {\n            envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n        }\n        catch (err) {\n            err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\n            throw err;\n        }\n        if (!envelope) {\n            throw new Error(\"Can't parse token envelope: \" + segments[0]);\n        }\n        try {\n            payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n        }\n        catch (err) {\n            err.message = `Can't parse token payload '${segments[0]}`;\n            throw err;\n        }\n        if (!payload) {\n            throw new Error(\"Can't parse token payload: \" + segments[1]);\n        }\n        if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n            // If this is not present, then there's no reason to attempt verification\n            throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n        }\n        const cert = certs[envelope.kid];\n        if (envelope.alg === 'ES256') {\n            signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\n        }\n        const verified = await crypto.verify(cert, signed, signature);\n        if (!verified) {\n            throw new Error('Invalid token signature: ' + jwt);\n        }\n        if (!payload.iat) {\n            throw new Error('No issue time in token: ' + JSON.stringify(payload));\n        }\n        if (!payload.exp) {\n            throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n        }\n        const iat = Number(payload.iat);\n        if (isNaN(iat))\n            throw new Error('iat field using invalid format');\n        const exp = Number(payload.exp);\n        if (isNaN(exp))\n            throw new Error('exp field using invalid format');\n        const now = new Date().getTime() / 1000;\n        if (exp >= now + maxExpiry) {\n            throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n        }\n        const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n        const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n        if (now < earliest) {\n            throw new Error('Token used too early, ' +\n                now +\n                ' < ' +\n                earliest +\n                ': ' +\n                JSON.stringify(payload));\n        }\n        if (now > latest) {\n            throw new Error('Token used too late, ' +\n                now +\n                ' > ' +\n                latest +\n                ': ' +\n                JSON.stringify(payload));\n        }\n        if (issuers && issuers.indexOf(payload.iss) < 0) {\n            throw new Error('Invalid issuer, expected one of [' +\n                issuers +\n                '], but got ' +\n                payload.iss);\n        }\n        // Check the audience matches if we have one\n        if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n            const aud = payload.aud;\n            let audVerified = false;\n            // If the requiredAudience is an array, check if it contains token\n            // audience\n            if (requiredAudience.constructor === Array) {\n                audVerified = requiredAudience.indexOf(aud) > -1;\n            }\n            else {\n                audVerified = aud === requiredAudience;\n            }\n            if (!audVerified) {\n                throw new Error('Wrong recipient, payload audience != requiredAudience');\n            }\n        }\n        return new loginticket_1.LoginTicket(envelope, payload);\n    }\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */\n    isTokenExpiring() {\n        const expiryDate = this.credentials.expiry_date;\n        return expiryDate\n            ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.OAuth2Client = OAuth2Client;\nOAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n/**\n * The base URL for auth endpoints.\n */\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n/**\n * The base endpoint for token retrieval.\n */\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n/**\n * The base endpoint to revoke tokens.\n */\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n/**\n * Google Sign on certificates in PEM format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n/**\n * Google Sign on certificates in JWK format.\n */\nOAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';\n/**\n * Clock skew - five minutes in seconds\n */\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n */\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n */\nOAuth2Client.ISSUERS_ = [\n    'accounts.google.com',\n    'https://accounts.google.com',\n];\n//# sourceMappingURL=oauth2client.js.map"]},"metadata":{},"sourceType":"script"}