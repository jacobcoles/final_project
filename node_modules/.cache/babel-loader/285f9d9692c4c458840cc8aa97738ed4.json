{"ast":null,"code":"\"use strict\"; // Copyright 2013 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _regeneratorRuntime = require(\"/Users/jacobcoles/Desktop/LT2216/final_project/final_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/jacobcoles/Desktop/LT2216/final_project/final_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JWT = void 0;\n\nconst gtoken_1 = require(\"gtoken\");\n\nconst jwtaccess_1 = require(\"./jwtaccess\");\n\nconst oauth2client_1 = require(\"./oauth2client\");\n\nclass JWT extends oauth2client_1.OAuth2Client {\n  constructor(optionsOrEmail, keyFile, key, scopes, subject, keyId) {\n    const opts = optionsOrEmail && typeof optionsOrEmail === 'object' ? optionsOrEmail : {\n      email: optionsOrEmail,\n      keyFile,\n      key,\n      keyId,\n      scopes,\n      subject\n    };\n    super({\n      eagerRefreshThresholdMillis: opts.eagerRefreshThresholdMillis,\n      forceRefreshOnFailure: opts.forceRefreshOnFailure\n    });\n    this.email = opts.email;\n    this.keyFile = opts.keyFile;\n    this.key = opts.key;\n    this.keyId = opts.keyId;\n    this.scopes = opts.scopes;\n    this.subject = opts.subject;\n    this.additionalClaims = opts.additionalClaims;\n    this.credentials = {\n      refresh_token: 'jwt-placeholder',\n      expiry_date: 1\n    };\n  }\n  /**\n   * Creates a copy of the credential with the specified scopes.\n   * @param scopes List of requested scopes or a single scope.\n   * @return The cloned instance.\n   */\n\n\n  createScoped(scopes) {\n    return new JWT({\n      email: this.email,\n      keyFile: this.keyFile,\n      key: this.key,\n      keyId: this.keyId,\n      scopes,\n      subject: this.subject,\n      additionalClaims: this.additionalClaims\n    });\n  }\n  /**\n   * Obtains the metadata to be sent with the request.\n   *\n   * @param url the URI being authorized.\n   */\n\n\n  getRequestMetadataAsync(url) {\n    var _superprop_getGetRequestMetadataAsync = () => super.getRequestMetadataAsync,\n        _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var _yield$_this$refreshT, tokens, headers;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (!(!_this.apiKey && !_this.hasUserScopes() && url)) {\n              _context.next = 16;\n              break;\n            }\n\n            if (!(_this.additionalClaims && _this.additionalClaims.target_audience)) {\n              _context.next = 9;\n              break;\n            }\n\n            _context.next = 4;\n            return _this.refreshToken();\n\n          case 4:\n            _yield$_this$refreshT = _context.sent;\n            tokens = _yield$_this$refreshT.tokens;\n            return _context.abrupt(\"return\", {\n              headers: _this.addSharedMetadataHeaders({\n                Authorization: \"Bearer \".concat(tokens.id_token)\n              })\n            });\n\n          case 9:\n            // no scopes have been set, but a uri has been provided. Use JWTAccess\n            // credentials.\n            if (!_this.access) {\n              _this.access = new jwtaccess_1.JWTAccess(_this.email, _this.key, _this.keyId, _this.eagerRefreshThresholdMillis);\n            }\n\n            _context.next = 12;\n            return _this.access.getRequestHeaders(url, _this.additionalClaims);\n\n          case 12:\n            headers = _context.sent;\n            return _context.abrupt(\"return\", {\n              headers: _this.addSharedMetadataHeaders(headers)\n            });\n\n          case 14:\n            _context.next = 21;\n            break;\n\n          case 16:\n            if (!(_this.hasAnyScopes() || _this.apiKey)) {\n              _context.next = 20;\n              break;\n            }\n\n            return _context.abrupt(\"return\", _superprop_getGetRequestMetadataAsync().call(_this, url));\n\n          case 20:\n            return _context.abrupt(\"return\", {\n              headers: {}\n            });\n\n          case 21:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }))();\n  }\n  /**\n   * Fetches an ID token.\n   * @param targetAudience the audience for the fetched ID token.\n   */\n\n\n  fetchIdToken(targetAudience) {\n    var _this2 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var gtoken;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            // Create a new gToken for fetching an ID token\n            gtoken = new gtoken_1.GoogleToken({\n              iss: _this2.email,\n              sub: _this2.subject,\n              scope: _this2.scopes || _this2.defaultScopes,\n              keyFile: _this2.keyFile,\n              key: _this2.key,\n              additionalClaims: {\n                target_audience: targetAudience\n              }\n            });\n            _context2.next = 3;\n            return gtoken.getToken({\n              forceRefresh: true\n            });\n\n          case 3:\n            if (gtoken.idToken) {\n              _context2.next = 5;\n              break;\n            }\n\n            throw new Error('Unknown error: Failed to fetch ID token');\n\n          case 5:\n            return _context2.abrupt(\"return\", gtoken.idToken);\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }))();\n  }\n  /**\n   * Determine if there are currently scopes available.\n   */\n\n\n  hasUserScopes() {\n    if (!this.scopes) {\n      return false;\n    }\n\n    return this.scopes.length > 0;\n  }\n  /**\n   * Are there any default or user scopes defined.\n   */\n\n\n  hasAnyScopes() {\n    if (this.scopes && this.scopes.length > 0) return true;\n    if (this.defaultScopes && this.defaultScopes.length > 0) return true;\n    return false;\n  }\n\n  authorize(callback) {\n    if (callback) {\n      this.authorizeAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.authorizeAsync();\n    }\n  }\n\n  authorizeAsync() {\n    var _this3 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var result;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return _this3.refreshToken();\n\n          case 2:\n            result = _context3.sent;\n\n            if (result) {\n              _context3.next = 5;\n              break;\n            }\n\n            throw new Error('No result returned');\n\n          case 5:\n            _this3.credentials = result.tokens;\n            _this3.credentials.refresh_token = 'jwt-placeholder';\n            _this3.key = _this3.gtoken.key;\n            _this3.email = _this3.gtoken.iss;\n            return _context3.abrupt(\"return\", result.tokens);\n\n          case 10:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }))();\n  }\n  /**\n   * Refreshes the access token.\n   * @param refreshToken ignored\n   * @private\n   */\n\n\n  refreshTokenNoCache( // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  refreshToken) {\n    var _this4 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      var gtoken, token, tokens;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            gtoken = _this4.createGToken();\n            _context4.next = 3;\n            return gtoken.getToken({\n              forceRefresh: _this4.isTokenExpiring()\n            });\n\n          case 3:\n            token = _context4.sent;\n            tokens = {\n              access_token: token.access_token,\n              token_type: 'Bearer',\n              expiry_date: gtoken.expiresAt,\n              id_token: gtoken.idToken\n            };\n\n            _this4.emit('tokens', tokens);\n\n            return _context4.abrupt(\"return\", {\n              res: null,\n              tokens\n            });\n\n          case 7:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }))();\n  }\n  /**\n   * Create a gToken if it doesn't already exist.\n   */\n\n\n  createGToken() {\n    if (!this.gtoken) {\n      this.gtoken = new gtoken_1.GoogleToken({\n        iss: this.email,\n        sub: this.subject,\n        scope: this.scopes || this.defaultScopes,\n        keyFile: this.keyFile,\n        key: this.key,\n        additionalClaims: this.additionalClaims\n      });\n    }\n\n    return this.gtoken;\n  }\n  /**\n   * Create a JWT credentials instance using the given input options.\n   * @param json The input object.\n   */\n\n\n  fromJSON(json) {\n    if (!json) {\n      throw new Error('Must pass in a JSON object containing the service account auth settings.');\n    }\n\n    if (!json.client_email) {\n      throw new Error('The incoming JSON object does not contain a client_email field');\n    }\n\n    if (!json.private_key) {\n      throw new Error('The incoming JSON object does not contain a private_key field');\n    } // Extract the relevant information from the json key file.\n\n\n    this.email = json.client_email;\n    this.key = json.private_key;\n    this.keyId = json.private_key_id;\n    this.projectId = json.project_id;\n    this.quotaProjectId = json.quota_project_id;\n  }\n\n  fromStream(inputStream, callback) {\n    if (callback) {\n      this.fromStreamAsync(inputStream).then(() => callback(), callback);\n    } else {\n      return this.fromStreamAsync(inputStream);\n    }\n  }\n\n  fromStreamAsync(inputStream) {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        throw new Error('Must pass in a stream containing the service account auth settings.');\n      }\n\n      let s = '';\n      inputStream.setEncoding('utf8').on('error', reject).on('data', chunk => s += chunk).on('end', () => {\n        try {\n          const data = JSON.parse(s);\n          this.fromJSON(data);\n          resolve();\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n  /**\n   * Creates a JWT credentials instance using an API Key for authentication.\n   * @param apiKey The API Key in string form.\n   */\n\n\n  fromAPIKey(apiKey) {\n    if (typeof apiKey !== 'string') {\n      throw new Error('Must provide an API Key string.');\n    }\n\n    this.apiKey = apiKey;\n  }\n  /**\n   * Using the key or keyFile on the JWT client, obtain an object that contains\n   * the key and the client email.\n   */\n\n\n  getCredentials() {\n    var _this5 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n      var gtoken, creds;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            if (!_this5.key) {\n              _context5.next = 4;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", {\n              private_key: _this5.key,\n              client_email: _this5.email\n            });\n\n          case 4:\n            if (!_this5.keyFile) {\n              _context5.next = 10;\n              break;\n            }\n\n            gtoken = _this5.createGToken();\n            _context5.next = 8;\n            return gtoken.getCredentials(_this5.keyFile);\n\n          case 8:\n            creds = _context5.sent;\n            return _context5.abrupt(\"return\", {\n              private_key: creds.privateKey,\n              client_email: creds.clientEmail\n            });\n\n          case 10:\n            throw new Error('A key or a keyFile must be provided to getCredentials.');\n\n          case 11:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }))();\n  }\n\n}\n\nexports.JWT = JWT;","map":{"version":3,"sources":["/Users/jacobcoles/Desktop/LT2216/final_project/final_project/node_modules/google-auth-library/build/src/auth/jwtclient.js"],"names":["Object","defineProperty","exports","value","JWT","gtoken_1","require","jwtaccess_1","oauth2client_1","OAuth2Client","constructor","optionsOrEmail","keyFile","key","scopes","subject","keyId","opts","email","eagerRefreshThresholdMillis","forceRefreshOnFailure","additionalClaims","credentials","refresh_token","expiry_date","createScoped","getRequestMetadataAsync","url","apiKey","hasUserScopes","target_audience","refreshToken","tokens","headers","addSharedMetadataHeaders","Authorization","id_token","access","JWTAccess","getRequestHeaders","hasAnyScopes","fetchIdToken","targetAudience","gtoken","GoogleToken","iss","sub","scope","defaultScopes","getToken","forceRefresh","idToken","Error","length","authorize","callback","authorizeAsync","then","r","result","refreshTokenNoCache","createGToken","isTokenExpiring","token","access_token","token_type","expiresAt","emit","res","fromJSON","json","client_email","private_key","private_key_id","projectId","project_id","quotaProjectId","quota_project_id","fromStream","inputStream","fromStreamAsync","Promise","resolve","reject","s","setEncoding","on","chunk","data","JSON","parse","e","fromAPIKey","getCredentials","creds","privateKey","clientEmail"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2013 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JWT = void 0;\nconst gtoken_1 = require(\"gtoken\");\nconst jwtaccess_1 = require(\"./jwtaccess\");\nconst oauth2client_1 = require(\"./oauth2client\");\nclass JWT extends oauth2client_1.OAuth2Client {\n    constructor(optionsOrEmail, keyFile, key, scopes, subject, keyId) {\n        const opts = optionsOrEmail && typeof optionsOrEmail === 'object'\n            ? optionsOrEmail\n            : { email: optionsOrEmail, keyFile, key, keyId, scopes, subject };\n        super({\n            eagerRefreshThresholdMillis: opts.eagerRefreshThresholdMillis,\n            forceRefreshOnFailure: opts.forceRefreshOnFailure,\n        });\n        this.email = opts.email;\n        this.keyFile = opts.keyFile;\n        this.key = opts.key;\n        this.keyId = opts.keyId;\n        this.scopes = opts.scopes;\n        this.subject = opts.subject;\n        this.additionalClaims = opts.additionalClaims;\n        this.credentials = { refresh_token: 'jwt-placeholder', expiry_date: 1 };\n    }\n    /**\n     * Creates a copy of the credential with the specified scopes.\n     * @param scopes List of requested scopes or a single scope.\n     * @return The cloned instance.\n     */\n    createScoped(scopes) {\n        return new JWT({\n            email: this.email,\n            keyFile: this.keyFile,\n            key: this.key,\n            keyId: this.keyId,\n            scopes,\n            subject: this.subject,\n            additionalClaims: this.additionalClaims,\n        });\n    }\n    /**\n     * Obtains the metadata to be sent with the request.\n     *\n     * @param url the URI being authorized.\n     */\n    async getRequestMetadataAsync(url) {\n        if (!this.apiKey && !this.hasUserScopes() && url) {\n            if (this.additionalClaims &&\n                this.additionalClaims.target_audience) {\n                const { tokens } = await this.refreshToken();\n                return {\n                    headers: this.addSharedMetadataHeaders({\n                        Authorization: `Bearer ${tokens.id_token}`,\n                    }),\n                };\n            }\n            else {\n                // no scopes have been set, but a uri has been provided. Use JWTAccess\n                // credentials.\n                if (!this.access) {\n                    this.access = new jwtaccess_1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);\n                }\n                const headers = await this.access.getRequestHeaders(url, this.additionalClaims);\n                return { headers: this.addSharedMetadataHeaders(headers) };\n            }\n        }\n        else if (this.hasAnyScopes() || this.apiKey) {\n            return super.getRequestMetadataAsync(url);\n        }\n        else {\n            // If no audience, apiKey, or scopes are provided, we should not attempt\n            // to populate any headers:\n            return { headers: {} };\n        }\n    }\n    /**\n     * Fetches an ID token.\n     * @param targetAudience the audience for the fetched ID token.\n     */\n    async fetchIdToken(targetAudience) {\n        // Create a new gToken for fetching an ID token\n        const gtoken = new gtoken_1.GoogleToken({\n            iss: this.email,\n            sub: this.subject,\n            scope: this.scopes || this.defaultScopes,\n            keyFile: this.keyFile,\n            key: this.key,\n            additionalClaims: { target_audience: targetAudience },\n        });\n        await gtoken.getToken({\n            forceRefresh: true,\n        });\n        if (!gtoken.idToken) {\n            throw new Error('Unknown error: Failed to fetch ID token');\n        }\n        return gtoken.idToken;\n    }\n    /**\n     * Determine if there are currently scopes available.\n     */\n    hasUserScopes() {\n        if (!this.scopes) {\n            return false;\n        }\n        return this.scopes.length > 0;\n    }\n    /**\n     * Are there any default or user scopes defined.\n     */\n    hasAnyScopes() {\n        if (this.scopes && this.scopes.length > 0)\n            return true;\n        if (this.defaultScopes && this.defaultScopes.length > 0)\n            return true;\n        return false;\n    }\n    authorize(callback) {\n        if (callback) {\n            this.authorizeAsync().then(r => callback(null, r), callback);\n        }\n        else {\n            return this.authorizeAsync();\n        }\n    }\n    async authorizeAsync() {\n        const result = await this.refreshToken();\n        if (!result) {\n            throw new Error('No result returned');\n        }\n        this.credentials = result.tokens;\n        this.credentials.refresh_token = 'jwt-placeholder';\n        this.key = this.gtoken.key;\n        this.email = this.gtoken.iss;\n        return result.tokens;\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken ignored\n     * @private\n     */\n    async refreshTokenNoCache(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        const gtoken = this.createGToken();\n        const token = await gtoken.getToken({\n            forceRefresh: this.isTokenExpiring(),\n        });\n        const tokens = {\n            access_token: token.access_token,\n            token_type: 'Bearer',\n            expiry_date: gtoken.expiresAt,\n            id_token: gtoken.idToken,\n        };\n        this.emit('tokens', tokens);\n        return { res: null, tokens };\n    }\n    /**\n     * Create a gToken if it doesn't already exist.\n     */\n    createGToken() {\n        if (!this.gtoken) {\n            this.gtoken = new gtoken_1.GoogleToken({\n                iss: this.email,\n                sub: this.subject,\n                scope: this.scopes || this.defaultScopes,\n                keyFile: this.keyFile,\n                key: this.key,\n                additionalClaims: this.additionalClaims,\n            });\n        }\n        return this.gtoken;\n    }\n    /**\n     * Create a JWT credentials instance using the given input options.\n     * @param json The input object.\n     */\n    fromJSON(json) {\n        if (!json) {\n            throw new Error('Must pass in a JSON object containing the service account auth settings.');\n        }\n        if (!json.client_email) {\n            throw new Error('The incoming JSON object does not contain a client_email field');\n        }\n        if (!json.private_key) {\n            throw new Error('The incoming JSON object does not contain a private_key field');\n        }\n        // Extract the relevant information from the json key file.\n        this.email = json.client_email;\n        this.key = json.private_key;\n        this.keyId = json.private_key_id;\n        this.projectId = json.project_id;\n        this.quotaProjectId = json.quota_project_id;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(() => callback(), callback);\n        }\n        else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject) => {\n            if (!inputStream) {\n                throw new Error('Must pass in a stream containing the service account auth settings.');\n            }\n            let s = '';\n            inputStream\n                .setEncoding('utf8')\n                .on('error', reject)\n                .on('data', chunk => (s += chunk))\n                .on('end', () => {\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    resolve();\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * Creates a JWT credentials instance using an API Key for authentication.\n     * @param apiKey The API Key in string form.\n     */\n    fromAPIKey(apiKey) {\n        if (typeof apiKey !== 'string') {\n            throw new Error('Must provide an API Key string.');\n        }\n        this.apiKey = apiKey;\n    }\n    /**\n     * Using the key or keyFile on the JWT client, obtain an object that contains\n     * the key and the client email.\n     */\n    async getCredentials() {\n        if (this.key) {\n            return { private_key: this.key, client_email: this.email };\n        }\n        else if (this.keyFile) {\n            const gtoken = this.createGToken();\n            const creds = await gtoken.getCredentials(this.keyFile);\n            return { private_key: creds.privateKey, client_email: creds.clientEmail };\n        }\n        throw new Error('A key or a keyFile must be provided to getCredentials.');\n    }\n}\nexports.JWT = JWT;\n//# sourceMappingURL=jwtclient.js.map"]},"metadata":{},"sourceType":"script"}