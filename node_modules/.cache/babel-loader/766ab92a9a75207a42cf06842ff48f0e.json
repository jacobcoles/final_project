{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _regeneratorRuntime = require(\"/Users/jacobcoles/Desktop/LT2216/final_project/final_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/jacobcoles/Desktop/LT2216/final_project/final_project/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseExternalAccountClient = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\n\nconst stream = require(\"stream\");\n\nconst authclient_1 = require(\"./authclient\");\n\nconst sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\n\n\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\n\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The default OAuth scope to request when none is provided. */\n\nconst DEFAULT_OAUTH_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\n/**\n * Offset to take into account network delays and server clock skews.\n */\n\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * The credentials JSON file type for external account clients.\n * There are 3 types of JSON configs:\n * 1. authorized_user => Google end user credential\n * 2. service_account => Google service account credential\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\n */\n\nexports.EXTERNAL_ACCOUNT_TYPE = 'external_account';\n/** Cloud resource manager URL used to retrieve project information. */\n\nexports.CLOUD_RESOURCE_MANAGER = 'https://cloudresourcemanager.googleapis.com/v1/projects/';\n/**\n * Base external account client. This is used to instantiate AuthClients for\n * exchanging external account credentials for GCP access token and authorizing\n * requests to GCP APIs.\n * The base class implements common logic for exchanging various type of\n * external credentials for GCP access token. The logic of determining and\n * retrieving the external credential based on the environment and\n * credential_source will be left for the subclasses.\n */\n\nclass BaseExternalAccountClient extends authclient_1.AuthClient {\n  /**\n   * Instantiate a BaseExternalAccountClient instance using the provided JSON\n   * object loaded from an external account credentials file.\n   * @param options The external account options object typically loaded\n   *   from the external account JSON credential file.\n   * @param additionalOptions Optional additional behavior customization\n   *   options. These currently customize expiration threshold time and\n   *   whether to retry on 401/403 API request errors.\n   */\n  constructor(options, additionalOptions) {\n    super();\n\n    if (options.type !== exports.EXTERNAL_ACCOUNT_TYPE) {\n      throw new Error(\"Expected \\\"\".concat(exports.EXTERNAL_ACCOUNT_TYPE, \"\\\" type but \") + \"received \\\"\".concat(options.type, \"\\\"\"));\n    }\n\n    const clientAuth = options.client_id ? {\n      confidentialClientType: 'basic',\n      clientId: options.client_id,\n      clientSecret: options.client_secret\n    } : undefined;\n    this.stsCredential = new sts.StsCredentials(options.token_url, clientAuth); // Default OAuth scope. This could be overridden via public property.\n\n    this.scopes = [DEFAULT_OAUTH_SCOPE];\n    this.cachedAccessToken = null;\n    this.audience = options.audience;\n    this.subjectTokenType = options.subject_token_type;\n    this.quotaProjectId = options.quota_project_id;\n    this.serviceAccountImpersonationUrl = options.service_account_impersonation_url; // As threshold could be zero,\n    // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n    // zero value.\n\n    if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n      this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n    } else {\n      this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n    }\n\n    this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n    this.projectId = null;\n    this.projectNumber = this.getProjectNumber(this.audience);\n  }\n  /**\n   * Provides a mechanism to inject GCP access tokens directly.\n   * When the provided credential expires, a new credential, using the\n   * external account options, is retrieved.\n   * @param credentials The Credentials object to set on the current client.\n   */\n\n\n  setCredentials(credentials) {\n    super.setCredentials(credentials);\n    this.cachedAccessToken = credentials;\n  }\n  /**\n   * @return A promise that resolves with the current GCP access token\n   *   response. If the current credential is expired, a new one is retrieved.\n   */\n\n\n  getAccessToken() {\n    var _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (!(!_this.cachedAccessToken || _this.isExpired(_this.cachedAccessToken))) {\n              _context.next = 3;\n              break;\n            }\n\n            _context.next = 3;\n            return _this.refreshAccessTokenAsync();\n\n          case 3:\n            return _context.abrupt(\"return\", {\n              token: _this.cachedAccessToken.access_token,\n              res: _this.cachedAccessToken.res\n            });\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }))();\n  }\n  /**\n   * The main authentication interface. It takes an optional url which when\n   * present is the endpoint> being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * The result has the form:\n   * { Authorization: 'Bearer <access_token_value>' }\n   */\n\n\n  getRequestHeaders() {\n    var _this2 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var accessTokenResponse, headers;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return _this2.getAccessToken();\n\n          case 2:\n            accessTokenResponse = _context2.sent;\n            headers = {\n              Authorization: \"Bearer \".concat(accessTokenResponse.token)\n            };\n            return _context2.abrupt(\"return\", _this2.addSharedMetadataHeaders(headers));\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }))();\n  }\n\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n  /**\n   * @return A promise that resolves with the project ID corresponding to the\n   *   current workload identity pool. When not determinable, this resolves with\n   *   null.\n   *   This is introduced to match the current pattern of using the Auth\n   *   library:\n   *   const projectId = await auth.getProjectId();\n   *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\n   *   const res = await client.request({ url });\n   *   The resource may not have permission\n   *   (resourcemanager.projects.get) to call this API or the required\n   *   scopes may not be selected:\n   *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n   */\n\n\n  getProjectId() {\n    var _this3 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var headers, response;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!_this3.projectId) {\n              _context3.next = 4;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", _this3.projectId);\n\n          case 4:\n            if (!_this3.projectNumber) {\n              _context3.next = 13;\n              break;\n            }\n\n            _context3.next = 7;\n            return _this3.getRequestHeaders();\n\n          case 7:\n            headers = _context3.sent;\n            _context3.next = 10;\n            return _this3.transporter.request({\n              headers,\n              url: \"\".concat(exports.CLOUD_RESOURCE_MANAGER).concat(_this3.projectNumber),\n              responseType: 'json'\n            });\n\n          case 10:\n            response = _context3.sent;\n            _this3.projectId = response.data.projectId;\n            return _context3.abrupt(\"return\", _this3.projectId);\n\n          case 13:\n            return _context3.abrupt(\"return\", null);\n\n          case 14:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }))();\n  }\n  /**\n   * Authenticates the provided HTTP request, processes it and resolves with the\n   * returned response.\n   * @param opts The HTTP request options.\n   * @param retry Whether the current attempt is a retry after a failed attempt.\n   * @return A promise that resolves with the successful response.\n   */\n\n\n  requestAsync(opts, retry = false) {\n    var _this4 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      var response, requestHeaders, res, statusCode, isReadableStream, isAuthErr;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            _context4.next = 3;\n            return _this4.getRequestHeaders();\n\n          case 3:\n            requestHeaders = _context4.sent;\n            opts.headers = opts.headers || {};\n\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\n              opts.headers['x-goog-user-project'] = requestHeaders['x-goog-user-project'];\n            }\n\n            if (requestHeaders && requestHeaders.Authorization) {\n              opts.headers.Authorization = requestHeaders.Authorization;\n            }\n\n            _context4.next = 9;\n            return _this4.transporter.request(opts);\n\n          case 9:\n            response = _context4.sent;\n            _context4.next = 26;\n            break;\n\n          case 12:\n            _context4.prev = 12;\n            _context4.t0 = _context4[\"catch\"](0);\n            res = _context4.t0.response;\n\n            if (!res) {\n              _context4.next = 25;\n              break;\n            }\n\n            statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n            // - We haven't already retried.  It only makes sense to retry once.\n            // - The response was a 401 or a 403\n            // - The request didn't send a readableStream\n            // - forceRefreshOnFailure is true\n\n            isReadableStream = res.config.data instanceof stream.Readable;\n            isAuthErr = statusCode === 401 || statusCode === 403;\n\n            if (!(!retry && isAuthErr && !isReadableStream && _this4.forceRefreshOnFailure)) {\n              _context4.next = 25;\n              break;\n            }\n\n            _context4.next = 22;\n            return _this4.refreshAccessTokenAsync();\n\n          case 22:\n            _context4.next = 24;\n            return _this4.requestAsync(opts, true);\n\n          case 24:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 25:\n            throw _context4.t0;\n\n          case 26:\n            return _context4.abrupt(\"return\", response);\n\n          case 27:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4, null, [[0, 12]]);\n    }))();\n  }\n  /**\n   * Forces token refresh, even if unexpired tokens are currently cached.\n   * External credentials are exchanged for GCP access tokens via the token\n   * exchange endpoint and other settings provided in the client options\n   * object.\n   * If the service_account_impersonation_url is provided, an additional\n   * step to exchange the external account GCP access token for a service\n   * account impersonated token is performed.\n   * @return A promise that resolves with the fresh GCP access tokens.\n   */\n\n\n  refreshAccessTokenAsync() {\n    var _this5 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n      var subjectToken, stsCredentialsOptions, stsResponse;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return _this5.retrieveSubjectToken();\n\n          case 2:\n            subjectToken = _context5.sent;\n            // Construct the STS credentials options.\n            stsCredentialsOptions = {\n              grantType: STS_GRANT_TYPE,\n              audience: _this5.audience,\n              requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n              subjectToken,\n              subjectTokenType: _this5.subjectTokenType,\n              // generateAccessToken requires the provided access token to have\n              // scopes:\n              // https://www.googleapis.com/auth/iam or\n              // https://www.googleapis.com/auth/cloud-platform\n              // The new service account access token scopes will match the user\n              // provided ones.\n              scope: _this5.serviceAccountImpersonationUrl ? [DEFAULT_OAUTH_SCOPE] : _this5.getScopesArray()\n            }; // Exchange the external credentials for a GCP access token.\n\n            _context5.next = 6;\n            return _this5.stsCredential.exchangeToken(stsCredentialsOptions);\n\n          case 6:\n            stsResponse = _context5.sent;\n\n            if (!_this5.serviceAccountImpersonationUrl) {\n              _context5.next = 13;\n              break;\n            }\n\n            _context5.next = 10;\n            return _this5.getImpersonatedAccessToken(stsResponse.access_token);\n\n          case 10:\n            _this5.cachedAccessToken = _context5.sent;\n            _context5.next = 14;\n            break;\n\n          case 13:\n            // Save response in cached access token.\n            _this5.cachedAccessToken = {\n              access_token: stsResponse.access_token,\n              expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n              res: stsResponse.res\n            };\n\n          case 14:\n            // Save credentials.\n            _this5.credentials = {};\n            Object.assign(_this5.credentials, _this5.cachedAccessToken);\n            delete _this5.credentials.res; // Trigger tokens event to notify external listeners.\n\n            _this5.emit('tokens', {\n              refresh_token: null,\n              expiry_date: _this5.cachedAccessToken.expiry_date,\n              access_token: _this5.cachedAccessToken.access_token,\n              token_type: 'Bearer',\n              id_token: null\n            }); // Return the cached access token.\n\n\n            return _context5.abrupt(\"return\", _this5.cachedAccessToken);\n\n          case 19:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }))();\n  }\n  /**\n   * Returns the workload identity pool project number if it is determinable\n   * from the audience resource name.\n   * @param audience The STS audience used to determine the project number.\n   * @return The project number associated with the workload identity pool, if\n   *   this can be determined from the STS audience field. Otherwise, null is\n   *   returned.\n   */\n\n\n  getProjectNumber(audience) {\n    // STS audience pattern:\n    // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n    const match = audience.match(/\\/projects\\/([^/]+)/);\n\n    if (!match) {\n      return null;\n    }\n\n    return match[1];\n  }\n  /**\n   * Exchanges an external account GCP access token for a service\n   * account impersonated access token using iamcredentials\n   * GenerateAccessToken API.\n   * @param token The access token to exchange for a service account access\n   *   token.\n   * @return A promise that resolves with the service account impersonated\n   *   credentials response.\n   */\n\n\n  getImpersonatedAccessToken(token) {\n    var _this6 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n      var opts, response, successResponse;\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            opts = {\n              url: _this6.serviceAccountImpersonationUrl,\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n                Authorization: \"Bearer \".concat(token)\n              },\n              data: {\n                scope: _this6.getScopesArray()\n              },\n              responseType: 'json'\n            };\n            _context6.next = 3;\n            return _this6.transporter.request(opts);\n\n          case 3:\n            response = _context6.sent;\n            successResponse = response.data;\n            return _context6.abrupt(\"return\", {\n              access_token: successResponse.accessToken,\n              // Convert from ISO format to timestamp.\n              expiry_date: new Date(successResponse.expireTime).getTime(),\n              res: response\n            });\n\n          case 6:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }))();\n  }\n  /**\n   * Returns whether the provided credentials are expired or not.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   * @param accessToken The credentials to check for expiration.\n   * @return Whether the credentials are expired or not.\n   */\n\n\n  isExpired(accessToken) {\n    const now = new Date().getTime();\n    return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n  }\n  /**\n   * @return The list of scopes for the requested GCP access token.\n   */\n\n\n  getScopesArray() {\n    // Since scopes can be provided as string or array, the type should\n    // be normalized.\n    if (typeof this.scopes === 'string') {\n      return [this.scopes];\n    } else if (typeof this.scopes === 'undefined') {\n      return [DEFAULT_OAUTH_SCOPE];\n    } else {\n      return this.scopes;\n    }\n  }\n\n}\n\nexports.BaseExternalAccountClient = BaseExternalAccountClient;","map":{"version":3,"sources":["/Users/jacobcoles/Desktop/LT2216/final_project/final_project/node_modules/google-auth-library/build/src/auth/baseexternalclient.js"],"names":["Object","defineProperty","exports","value","BaseExternalAccountClient","CLOUD_RESOURCE_MANAGER","EXTERNAL_ACCOUNT_TYPE","EXPIRATION_TIME_OFFSET","stream","require","authclient_1","sts","STS_GRANT_TYPE","STS_REQUEST_TOKEN_TYPE","DEFAULT_OAUTH_SCOPE","AuthClient","constructor","options","additionalOptions","type","Error","clientAuth","client_id","confidentialClientType","clientId","clientSecret","client_secret","undefined","stsCredential","StsCredentials","token_url","scopes","cachedAccessToken","audience","subjectTokenType","subject_token_type","quotaProjectId","quota_project_id","serviceAccountImpersonationUrl","service_account_impersonation_url","eagerRefreshThresholdMillis","forceRefreshOnFailure","projectId","projectNumber","getProjectNumber","setCredentials","credentials","getAccessToken","isExpired","refreshAccessTokenAsync","token","access_token","res","getRequestHeaders","accessTokenResponse","headers","Authorization","addSharedMetadataHeaders","request","opts","callback","requestAsync","then","r","e","response","getProjectId","transporter","url","responseType","data","retry","requestHeaders","statusCode","status","isReadableStream","config","Readable","isAuthErr","retrieveSubjectToken","subjectToken","stsCredentialsOptions","grantType","requestedTokenType","scope","getScopesArray","exchangeToken","stsResponse","getImpersonatedAccessToken","expiry_date","Date","getTime","expires_in","assign","emit","refresh_token","token_type","id_token","match","method","successResponse","accessToken","expireTime","now"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseExternalAccountClient = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\nconst stream = require(\"stream\");\nconst authclient_1 = require(\"./authclient\");\nconst sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The default OAuth scope to request when none is provided. */\nconst DEFAULT_OAUTH_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * The credentials JSON file type for external account clients.\n * There are 3 types of JSON configs:\n * 1. authorized_user => Google end user credential\n * 2. service_account => Google service account credential\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\n */\nexports.EXTERNAL_ACCOUNT_TYPE = 'external_account';\n/** Cloud resource manager URL used to retrieve project information. */\nexports.CLOUD_RESOURCE_MANAGER = 'https://cloudresourcemanager.googleapis.com/v1/projects/';\n/**\n * Base external account client. This is used to instantiate AuthClients for\n * exchanging external account credentials for GCP access token and authorizing\n * requests to GCP APIs.\n * The base class implements common logic for exchanging various type of\n * external credentials for GCP access token. The logic of determining and\n * retrieving the external credential based on the environment and\n * credential_source will be left for the subclasses.\n */\nclass BaseExternalAccountClient extends authclient_1.AuthClient {\n    /**\n     * Instantiate a BaseExternalAccountClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     */\n    constructor(options, additionalOptions) {\n        super();\n        if (options.type !== exports.EXTERNAL_ACCOUNT_TYPE) {\n            throw new Error(`Expected \"${exports.EXTERNAL_ACCOUNT_TYPE}\" type but ` +\n                `received \"${options.type}\"`);\n        }\n        const clientAuth = options.client_id\n            ? {\n                confidentialClientType: 'basic',\n                clientId: options.client_id,\n                clientSecret: options.client_secret,\n            }\n            : undefined;\n        this.stsCredential = new sts.StsCredentials(options.token_url, clientAuth);\n        // Default OAuth scope. This could be overridden via public property.\n        this.scopes = [DEFAULT_OAUTH_SCOPE];\n        this.cachedAccessToken = null;\n        this.audience = options.audience;\n        this.subjectTokenType = options.subject_token_type;\n        this.quotaProjectId = options.quota_project_id;\n        this.serviceAccountImpersonationUrl =\n            options.service_account_impersonation_url;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n            this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n        }\n        else {\n            this.eagerRefreshThresholdMillis = additionalOptions\n                .eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n        this.projectId = null;\n        this.projectNumber = this.getProjectNumber(this.audience);\n    }\n    /**\n     * Provides a mechanism to inject GCP access tokens directly.\n     * When the provided credential expires, a new credential, using the\n     * external account options, is retrieved.\n     * @param credentials The Credentials object to set on the current client.\n     */\n    setCredentials(credentials) {\n        super.setCredentials(credentials);\n        this.cachedAccessToken = credentials;\n    }\n    /**\n     * @return A promise that resolves with the current GCP access token\n     *   response. If the current credential is expired, a new one is retrieved.\n     */\n    async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res,\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint> being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`,\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * @return A promise that resolves with the project ID corresponding to the\n     *   current workload identity pool. When not determinable, this resolves with\n     *   null.\n     *   This is introduced to match the current pattern of using the Auth\n     *   library:\n     *   const projectId = await auth.getProjectId();\n     *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\n     *   const res = await client.request({ url });\n     *   The resource may not have permission\n     *   (resourcemanager.projects.get) to call this API or the required\n     *   scopes may not be selected:\n     *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n     */\n    async getProjectId() {\n        if (this.projectId) {\n            // Return previously determined project ID.\n            return this.projectId;\n        }\n        else if (this.projectNumber) {\n            // Preferable not to use request() to avoid retrial policies.\n            const headers = await this.getRequestHeaders();\n            const response = await this.transporter.request({\n                headers,\n                url: `${exports.CLOUD_RESOURCE_MANAGER}${this.projectNumber}`,\n                responseType: 'json',\n            });\n            this.projectId = response.data.projectId;\n            return this.projectId;\n        }\n        return null;\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */\n    async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] =\n                    requestHeaders['x-goog-user-project'];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * External credentials are exchanged for GCP access tokens via the token\n     * exchange endpoint and other settings provided in the client options\n     * object.\n     * If the service_account_impersonation_url is provided, an additional\n     * step to exchange the external account GCP access token for a service\n     * account impersonated token is performed.\n     * @return A promise that resolves with the fresh GCP access tokens.\n     */\n    async refreshAccessTokenAsync() {\n        // Retrieve the external credential.\n        const subjectToken = await this.retrieveSubjectToken();\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            audience: this.audience,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken,\n            subjectTokenType: this.subjectTokenType,\n            // generateAccessToken requires the provided access token to have\n            // scopes:\n            // https://www.googleapis.com/auth/iam or\n            // https://www.googleapis.com/auth/cloud-platform\n            // The new service account access token scopes will match the user\n            // provided ones.\n            scope: this.serviceAccountImpersonationUrl\n                ? [DEFAULT_OAUTH_SCOPE]\n                : this.getScopesArray(),\n        };\n        // Exchange the external credentials for a GCP access token.\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions);\n        if (this.serviceAccountImpersonationUrl) {\n            this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);\n        }\n        else {\n            // Save response in cached access token.\n            this.cachedAccessToken = {\n                access_token: stsResponse.access_token,\n                expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n                res: stsResponse.res,\n            };\n        }\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit('tokens', {\n            refresh_token: null,\n            expiry_date: this.cachedAccessToken.expiry_date,\n            access_token: this.cachedAccessToken.access_token,\n            token_type: 'Bearer',\n            id_token: null,\n        });\n        // Return the cached access token.\n        return this.cachedAccessToken;\n    }\n    /**\n     * Returns the workload identity pool project number if it is determinable\n     * from the audience resource name.\n     * @param audience The STS audience used to determine the project number.\n     * @return The project number associated with the workload identity pool, if\n     *   this can be determined from the STS audience field. Otherwise, null is\n     *   returned.\n     */\n    getProjectNumber(audience) {\n        // STS audience pattern:\n        // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n        const match = audience.match(/\\/projects\\/([^/]+)/);\n        if (!match) {\n            return null;\n        }\n        return match[1];\n    }\n    /**\n     * Exchanges an external account GCP access token for a service\n     * account impersonated access token using iamcredentials\n     * GenerateAccessToken API.\n     * @param token The access token to exchange for a service account access\n     *   token.\n     * @return A promise that resolves with the service account impersonated\n     *   credentials response.\n     */\n    async getImpersonatedAccessToken(token) {\n        const opts = {\n            url: this.serviceAccountImpersonationUrl,\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${token}`,\n            },\n            data: {\n                scope: this.getScopesArray(),\n            },\n            responseType: 'json',\n        };\n        const response = await this.transporter.request(opts);\n        const successResponse = response.data;\n        return {\n            access_token: successResponse.accessToken,\n            // Convert from ISO format to timestamp.\n            expiry_date: new Date(successResponse.expireTime).getTime(),\n            res: response,\n        };\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param accessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(accessToken) {\n        const now = new Date().getTime();\n        return accessToken.expiry_date\n            ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n    /**\n     * @return The list of scopes for the requested GCP access token.\n     */\n    getScopesArray() {\n        // Since scopes can be provided as string or array, the type should\n        // be normalized.\n        if (typeof this.scopes === 'string') {\n            return [this.scopes];\n        }\n        else if (typeof this.scopes === 'undefined') {\n            return [DEFAULT_OAUTH_SCOPE];\n        }\n        else {\n            return this.scopes;\n        }\n    }\n}\nexports.BaseExternalAccountClient = BaseExternalAccountClient;\n//# sourceMappingURL=baseexternalclient.js.map"]},"metadata":{},"sourceType":"script"}